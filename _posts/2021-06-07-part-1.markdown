---
layout: post
title: "Часть 1: Что это такое?"
permalink: /part-1/
---

## Краткая история СМ-1800

[ЭВМ серии СМ](https://ru.wikipedia.org/wiki/%D0%A1%D0%9C_%D0%AD%D0%92%D0%9C) -- разработанные в 1970-1980х годах советские компьютеры.

![ЭВМ СМ-1800](/assets/smevm_1.jpg)

*СМ 1803 -- вариант СМ-1800 в тумбочном исполнении. [© Совет Виртуального компьютерного музея, 1997 — 2022](https://www.computer-museum.ru/articles/sm-evm/1026/)*


Большинство из компьютеров этой серии были разработаны, чтобы быть совместимыми с западными разработками.
В частности, СМ-1800, про который идет речь, использует процессор [КР580ВМ80А](https://ru.wikipedia.org/wiki/%D0%9A%D0%A0580%D0%92%D0%9C80%D0%90),
который является полностью совместимым с [Intel 8080](https://ru.wikipedia.org/wiki/Intel_8080).
Поэтому, для задач поиска информации в интернете, в этом компьютере используется процессор Intel 8080.

## Устройство компьютера

Перейдем к более общему вопросу: как вообще работают такие компьютеры?
В общем говоря, у них есть несколько важных частей: процессор, память, и устройства ввода-вывода.
Последние мы пока не будем обсуждать.

Память компьютера -- это набор ячеек, каждая из которых имеет свой уникальный адрес и может хранить одно значение.
В контексте СМ-1800, существуют 65536 ячеек, каждая из которых может принимать одно из 256 значений.
Поэтому такая память имеет 16-битный адрес и содержит 8-битные значения.

### Примечание про форматы чисел

При обсуждении программ нам очень часто будет нужно говорить о адресах и значениях памяти.
Числа вроде 65536 и 256 бывают довольно трудны для восприятия, поэтому с самого изобретения двоичных компьютеров использовались особые форматы записи чисел:
двоичная, восьмеричная и шестнадцатеричная.
Мне будет нужна только [шестнадцатиричная](https://ru.wikipedia.org/wiki/%D0%A8%D0%B5%D1%81%D1%82%D0%BD%D0%B0%D0%B4%D1%86%D0%B0%D1%82%D0%B5%D1%80%D0%B8%D1%87%D0%BD%D0%B0%D1%8F_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0_%D1%81%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F), и возможно совсем немного -- [двоичная](https://ru.wikipedia.org/wiki/%D0%94%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D0%B0%D1%8F_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0_%D1%81%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F), поэтому здесь я приведу небольшое описание этих форматов.

{% comment %}

TODO: details tag does not work with Markdown, maybe remove entirely?

<details>
    <summary>А как работают такие системы счисления?</summary>
    Посмотрим на то, как в обычной десятичной системе записываются двухзначные числа:

    ```
    00
    01
    02
    03
    04
    05
    06
    07
    08
    09
    10
    11
    12
    13
    ...
    ```

    Первое число имеет обе ячейки равными нулю.
    Затем, в самой последней ячейке берутся все цифры последовательно: `1, 2, 3, ..., 9`.
    После того, как последняя ячейка достигла самой большой цифры, следующее число -- это такое, в котором последняя ячейка обнулилась, а предпоследняя стала больше (а если она тоже является самой большой цифрой, то обнуляется она и прибавляется следующая за ней, и так далее).
    Такая система счисления называется [позиционной системой счисления](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%B7%D0%B8%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0_%D1%81%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F), потому что в ней важно, на какой позиции стоит каждая цифра.

    Шестнадцатиричная система добавляет к десятичной системе шесть новых цифр: `abcdef`, имеющих значения от 10 до 15.
    Тогда, число `f` равно 15, а следующее число -- это число `10`, и оно равно 16.

    Двоичная система, наоборот, убирает почти все цифры.
    Остаются только `0` и `1`.

    Двоичное | Десятичное
    ---------|--------
    `0`      | 0
    `1`      | 1
    `10`     | 2
    `11`     | 3
    `100`    | 4
    `101`    | 5
    `110`    | 6
    `111`    | 7

</details>

{% endcomment %}

Из-за того, что мы будем использовать разные системы счисления, нам нужно договориться о том, как именно мы будем их представлять.
Здесь и далее:

- десятичные числа записываются без изменений: `9+1 = 10`
- двоичные числа записываются с префиксом `0b`: `0b10 = 2`, `0b11 = 3`, `0b1010 = 10`
- шестнадцатиричные числа записываются с префиксом `0x`: `0xf=15`, `0xf + 0x1 = 0x10 = 16`

В некоторой литературе шестнадцатиричные числа вместо этого записываются с постфиксом `h`: `Fh = 15`, `Fh + 1h = 10h = 16`.
Такой стандарт записи тоже существует, но я привык к `0x`, поэтому далее я буду использовать только `0x`.

Исключение составляет запись в блоках кода, где шестнадцатиричные числа будут записываться всегда в две цифры, по одиночке или в группах из двух цифр.
Например, следующая запись:

```
01 3490
CD 0049
C6 FF
76
```

будет соответствовать последовательности байтов `0x01`, `0x34`, `0x90`, `0xcd`, `0x00`, `0x49`, `0xc6`, `0xff`, `0x76`.


## Устройство компьютера: продолжение

Теперь, когда у нас есть способ представления чисел в шестнадцатиричной системе, мы можем сказать,
что в памяти есть ячейки с адресом от `0x0000` до `0xffff`, и каждая из них содержит число от `0x00` до `0xff`.

Значение этой ячейки имеет размер в один байт, или 8 бит. Это можно продемонстрировать, потому что `0xff = 0b11111111`, то есть самое большое значение можно представить с помощью 8 бит.
Аналогично, `0xffff = 0b1111111111111111`, то есть самое большое значение можно представить с помощью 16 бит.

Процессор связан с памятью.
Он отправляет в микросхему памяти 16 бит, описывающие адрес, и команду -- прочитать или записать в память.
Если команда записи, то процессор также передает определенные 8 бит, а память сохраняет их в указанную ячейку.
Если команда чтения, то память, наоборот, читает значение из указанной ячейки и передает его процессору.

В этой архитектуре компьютера [нет разделения между данными и программой](https://ru.wikipedia.org/wiki/%D0%90%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0_%D1%84%D0%BE%D0%BD_%D0%9D%D0%B5%D0%B9%D0%BC%D0%B0%D0%BD%D0%B0) -- программа, которую исполняет процессор, находится в той же самой памяти, как и данные, над которыми происходит работа.
В других архитектурах компьютеров [существует отдельная память для кода и для данных](https://ru.wikipedia.org/wiki/%D0%93%D0%B0%D1%80%D0%B2%D0%B0%D1%80%D0%B4%D1%81%D0%BA%D0%B0%D1%8F_%D0%B0%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0).

## Как процессор выполняет инструкции

Программа состоит из инструкций.
Каждая инструкция (на этом компьютере) описывается одним, двумя, или тремя байтами.

Внутри процессора есть *счетчик программы*, или *program counter*. Это -- 16 бит памяти, которые являются адресом памяти.

Когда процессор работает, он выполняет цикл [*fetch-decode-execute*](https://en.wikipedia.org/wiki/Instruction_cycle).
На шаге *fetch* процессор считывает из памяти по адресу в счетчике программы инструкцию.

На шаге *decode* процессор декодирует инструкцию -- определяет действие, которое будет выполнено, и параметры выполнения.
Здесь процессор может прочитать из памяти следующие байты -- параметры к инструкцию.

На шаге *execute* процессор выполняет инструкцию.
К этому моменту *program counter* уже указывает на инструкцию, которую процессор будет выполнять дальше, и после того как это выполнение завершится, процессор сделает *fetch* следующей инструкции.

Этот цикл начинается, когда процессор подключается к электричеству, и продолжается до его остановки -- 
либо отключением питания, либо при выполнении инструкции `HLT`.

## Пространство памяти

Когда процессор запускается, его *program counter* имеет значение `0x0000`.
Это значит, что он начнет выполнять код, находящийся в самом начале адресного пространства.
Какой код там расположен по умолчанию, зависит от того, что это за компьютер -- 
например, в настольных компьютерах это часто определенная программа в ПЗУ,
в то время как в игровых консолях это -- код, настраивающий оборудование для определенной игры, который загружается из картриджа.

В эмуляторе СМ-1800 первые два килобайта -- адреса от `0x0000` до `0x2000` -- занимает образ ПЗУ, содержащий так называемую *программу-монитор*.
Она предоставляет пользователю возможность вручную вводить данные в память, читать их из памяти, и выполнять код по определенному адресу.
Как пользоваться этой программой, и как вообще работать с эмулятором, мы рассмотрим в следующей статье.