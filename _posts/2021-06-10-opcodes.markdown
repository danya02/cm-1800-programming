---
layout: post
title: "Список и таблица опкодов"
permalink: /opcodes/
---

{% capture tldr %}
В этом посте:

- Список опкодов в порядке их бинарного кода
- Таблица опкодов
- Объяснение по категориям инструкций
{% endcapture %}
{% include info-callout.html content=tldr %}

# Аттрибуция

При составлении этой страницы использованы материалы:

- [Таблица опкодов на сайте Pastaraiser](https://www.pastraiser.com/cpu/i8080/i8080_opcodes.html), из которой я узнал про существование всех инструкций и использовал ее постоянно при написании программ
- [Intel 8080 Programmer's Manual](https://drakeor.com/uploads/8080-Programmers-Manual.pdf) -- официальное руководство к программированию для процессора I8080
- [исходный код для эмулятора Intel 8080](https://github.com/duongvuhong/intel8080)


# Категории инструкций

Все инструкции можно разделить на 6 категорий:
{% assign control="&#x1f527;" %}{% comment %}U+1F527 WRENCH{% endcomment %}
{% assign Hcontrol='<span markdown="0" class="icon icontrol">&#x1f527;</span>' %}
{% assign jumps="&#x2935;" %}{% comment %}U+2935 RIGHT ARROW CURVING DOWN{% endcomment %}
{% assign Hjumps='<span markdown="0" class="icon ijumps">&#x2935;</span>' %}
{% assign mov8="&#x1f4e9;" %}{% comment %}U+1F4E9 ENVELOPE WITH ARROW{% endcomment %}
{% assign Hmov8='<span markdown="0" class="icon imov8">&#x1f4e9;</span>' %}
{% assign mov16="&#x1f4e5;" %}{% comment %}U+1F4E5 INBOX TRAY{% endcomment %}
{% assign Hmov16='<span markdown="0" class="icon imov16">&#x1f4e5;</span>' %}
{% assign alu8="&#x1f9ee;" %}{% comment %}U+1F9EE ABACUS{% endcomment %}
{% assign Halu8='<span markdown="0" class="icon ialu8">&#x1f9ee;</span>' %}
{% assign alu16="&#x1f4d0;" %}{% comment %}U+1F4D0 TRIANGULAR RULER{% endcomment %}
{% assign Halu16='<span markdown="0" class="icon ialu16">&#x1f4d0;</span>' %}
{% assign danger="&#x1f92c;" %}{% comment %}U+1F92C FACE WITH SYMBOLS ON MOUTH{% endcomment %}
{% assign Hdanger='<span markdown="0" class="icon idanger">&#x1f92c;</span>' %}

{% assign noflags="&empty;" %}
{% assign into="←" %}{% comment %}U+2190 LEFT ARROW{% endcomment %}


- {{ control }} Управление процессором
- {{ jumps }} Переходы и вызовы
- {{ mov8 }} Загрузка, сохранение и перемещение, 8-бит
- {{ mov16 }} Загрузка, сохранение и перемещение, 16-бит
- {{ alu8 }} Арифметические и логические операции, 8-бит
- {{ alu16 }} Арифметические и логические операции, 16-бит

Некоторые инструкции не следует использовать. Они помечены: {{ danger }}.

# Список опкодов

<style markdown="0">
#opcodes > tbody > tr > td:first-child + td {
  font-size: xxx-large; /* make emoji column big */
}
</style>


Опкод (hex) | Категория | Мнемоника | Краткое описание  | Затронутые флаги | Ссылка на описание |
--------------------------|----------|------------|-------------------|------------------|-------------------|
<span markdown="0" id="x00">00</span> | {{control}} | NOP | Ничего не делает | {{noflags}} | [NOP](#nop) 
<span markdown="0" id="x01">01</span> {2} {3} | {{ mov16 }} | LXI B, d16 | B {{into}} {2}, C {{into}} {3} | {{noflags}} | [LXI](#lxi)
<span markdown="0" id="x02">02</span> | {{mov8}} | STAX B | (BC) {{into}} A | {{noflags}} | [LDAX/STAX](#ldax-stax)
<span markdown="0" id="x03">03</span> | {{ alu16 }} | INX B  | BC {{into}} BC + 1 | CY | [INX/DCX](#inx-dcx)
<span markdown="0" id="x04">04</span> | {{alu8}} | INR B | B {{into}} B + 1 | Z, S, P, AC | [INR/DCR](#inr-dcr)
<span markdown="0" id="x05">05</span> | {{alu8}} | DCR B | B {{into}} B - 1 | Z, S, P, AC | [INR/DCR](#inr-dcr)
<span markdown="0" id="x06">06</span> {2} | {{mov8}} | MVI B, d8 | B {{into}} {2} | {{noflags}} | [MVI](#mvi)
<span markdown="0" id="x07">07</span> | {{alu8}} | RLC | A {{into}} A << 1 (CY = пред. бит 7; бит 0 = пред. бит 7) | CY | [RLC/RRC/RAL/RAR](#rlc-rrc-ral-rar)
<span markdown="0" id="x08">08</span> | {{danger}} | {NOP} | !!! | {{noflags}} | [Неопределенные инструкции](#undefined-instructions)
<span markdown="0" id="x09">09</span> | {{ alu16 }} | DAD B | HL {{into}} HL + BC | {{noflags}} | [DAD](#dad)
<span markdown="0" id="x0a">0A</span> | {{mov8}} | LDAX B | A {{into}} (BC) | {{noflags}} | [LDAX/STAX](#ldax-stax)
<span markdown="0" id="x0b">0B</span> | {{ alu16 }} | DCX B | BC {{into}} BC - 1 | CY | [INX/DCX](#inx-dcx)
<span markdown="0" id="x0c">0C</span> | {{alu8}} | INR C | C {{into}} C + 1 | Z, S, P, AC | [INR/DCR](#inr-dcr)
<span markdown="0" id="x0d">0D</span> | {{alu8}} | DCR C | C {{into}} C - 1 | Z, S, P, AC | [INR/DCR](#inr-dcr)
<span markdown="0" id="x0e">0E</span> {2} | {{mov8}} | MVI C, d8 | C {{into}} {2} | {{noflags}} | [MVI](#mvi)
<span markdown="0" id="x0f">0F</span> | {{alu8}} | RRC | A {{into}} A >> 1 (CY = пред. бит 0; бит 7 = пред. бит 0) | CY | [RLC/RRC/RAL/RAR](#rlc-rrc-ral-rar)
|---
<span markdown="0" id="x10">10</span> | {{danger}} | {NOP} | !!! | {{noflags}} | [Неопределенные инструкции](#undefined-instructions)
<span markdown="0" id="x11">11</span> {2} {3} | {{ mov16 }} | LXI D, d16 | D {{into}} {2}, E {{into}} {3} | {{noflags}} | [LXI](#lxi)
<span markdown="0" id="x12">12</span> | {{mov8}} | STAX D | (DE) {{into}} A | {{noflags}} | [LDAX/STAX](#ldax-stax)
<span markdown="0" id="x13">13</span> | {{ alu16 }} | INX D  | DE {{into}} DE + 1 | CY | [INX/DCX](#inx-dcx)
<span markdown="0" id="x14">14</span> | {{alu8}} | INR D | D {{into}} D + 1 | Z, S, P, AC | [INR/DCR](#inr-dcr)
<span markdown="0" id="x15">15</span> | {{alu8}} | DCR D | D {{into}} D - 1 | Z, S, P, AC | [INR/DCR](#inr-dcr)
<span markdown="0" id="x16">16</span> {2} | {{mov8}} | MVI D, d8 | D {{into}} {2} | {{noflags}} | [MVI](#mvi)
<span markdown="0" id="x17">17</span> | {{alu8}} | RAL | A {{into}} A ≪ 1 (бит 0 = пред. CY, CY = пред. бит 7) | CY | [RLC/RRC/RAL/RAR](#rlc-rrc-ral-rar)
<span markdown="0" id="x18">18</span> | {{danger}} | {NOP} | !!! | {{noflags}} | [Неопределенные инструкции](#undefined-instructions)
<span markdown="0" id="x19">19</span> | {{ alu16 }} | DAD D | HL {{into}} HL + DE | {{noflags}} | [DAD](#dad)
<span markdown="0" id="x1a">1A</span> | {{mov8}} | LDAX D | A {{into}} (DE) | {{noflags}} | [LDAX/STAX](#ldax-stax)
<span markdown="0" id="x1b">1B</span> | {{ alu16 }} | DCX D | DE {{into}} DE - 1 | CY | [INX/DCX](#inx-dcx)
<span markdown="0" id="x1c">1C</span> | {{alu8}} | INR E | E {{into}} E + 1 | Z, S, P, AC | [INR/DCR](#inr-dcr)
<span markdown="0" id="x1d">1D</span> | {{alu8}} | DCR E | E {{into}} E - 1 | Z, S, P, AC | [INR/DCR](#inr-dcr)
<span markdown="0" id="x1e">1E</span> {2} | {{mov8}} | MVI E, d8 | E {{into}} {2} | {{noflags}} | [MVI](#mvi)
<span markdown="0" id="x1f">1F</span> | {{alu8}} | RAR | A {{into}} A ≫ 1 (бит 7 = пред. CY, CY = пред. бит 0) | CY | [RLC/RRC/RAL/RAR](#rlc-rrc-ral-rar)
|---
<span markdown="0" id="x20">20</span> | {{danger}} | {NOP} | !!! | {{noflags}} | [Неопределенные инструкции](#undefined-instructions)
<span markdown="0" id="x21">21</span> {2} {3} | {{ mov16 }} | LXI H, d16 | H {{into}} {2}, L {{into}} {3} | {{noflags}} | [LXI](#lxi)
<span markdown="0" id="x22">22</span> {2} {3} | {{ mov16 }} | SHLD a16 | (a16) {{into}} L, (a16+1) {{into}} H | {{noflags}} | [SHLD/LHLD](#shld-lhld)
<span markdown="0" id="x23">23</span> | {{ alu16 }} | INX H  | HL {{into}} HL + 1 | CY | [INX/DCX](#inx-dcx)
<span markdown="0" id="x24">24</span> | {{alu8}} | INR H | H {{into}} H + 1 | Z, S, P, AC | [INR/DCR](#inr-dcr)
<span markdown="0" id="x25">25</span> | {{alu8}} | DCR H | H {{into}} H - 1 | Z, S, P, AC | [INR/DCR](#inr-dcr)
<span markdown="0" id="x26">26</span> {2} | {{mov8}} | MVI H, d8 | H {{into}} {2} | {{noflags}} | [MVI](#mvi)
<span markdown="0" id="x27">27</span> | {{alu8}} | DAA | Преобразовать A в формат BCD | CY, AC | [DAA](#daa)
<span markdown="0" id="x28">28</span> | {{danger}} | {NOP} | !!! | {{noflags}} | [Неопределенные инструкции](#undefined-instructions)
<span markdown="0" id="x29">29</span> | {{ alu16 }} | DAD H | HL {{into}} HL + HL | {{noflags}} | [DAD](#dad)
<span markdown="0" id="x2a">2A</span> {2} {3} | {{ mov16 }} | LHLD a16 | L {{into}} (a16), H {{into}} (a16+1) | {{noflags}} | [LHLD/SHLD](#lhld-shld)
<span markdown="0" id="x2b">2B</span> | {{ alu16 }} | DCX H | HL {{into}} HL - 1 | CY | [INX/DCX](#inx-dcx)
<span markdown="0" id="x2c">2C</span> | {{alu8}} | INR L | L {{into}} L + 1 | Z, S, P, AC | [INR/DCR](#inr-dcr)
<span markdown="0" id="x2d">2D</span> | {{alu8}} | DCR L | L {{into}} L - 1 | Z, S, P, AC | [INR/DCR](#inr-dcr)
<span markdown="0" id="x2e">2E</span> {2} | {{mov8}} | MVI L, d8 | L {{into}} {2} | {{noflags}} | [MVI](#mvi)
<span markdown="0" id="x2f">2F</span> | {{alu8}} | CMA | A {{into}} ~A | {{noflags}} | [CMA](#cma)
|---
<span markdown="0" id="x30">30</span> | {{danger}} | {NOP} | !!! | {{noflags}} | [Неопределенные инструкции](#undefined-instructions)
<span markdown="0" id="x31">31</span> {2} {3} | {{ mov16 }} | LXI SP, d16 | SP {{into}} {2}, SP+1 {{into}} {3} | {{noflags}} | [LXI](#lxi)
<span markdown="0" id="x32">32</span> {2} {3} | {{mov8}} | STA a16 | (a16) {{into}} A | {{noflags}} | [STA](#lda-sta)
<span markdown="0" id="x33">33</span> | {{ alu16 }} | INX SP | SP {{into}} SP + 1 | CY | [INX/DCX](#inx-dcx)
<span markdown="0" id="x34">34</span> | {{alu8}} | INR M | (HL) {{into}} (HL) + 1 | Z, S, P, AC | [INR/DCR](#inr-dcr)
<span markdown="0" id="x35">35</span> | {{alu8}} | DCR M | (HL) {{into}} (HL) - 1 | Z, S, P, AC | [INR/DCR](#inr-dcr)
<span markdown="0" id="x36">36</span> {2} | {{mov8}} | MVI M, d8 | (HL) {{into}} {2} | {{noflags}} | [MVI](#mvi)
<span markdown="0" id="x37">37</span> | {{alu8}} | STC | CY {{into}} 1 | {{noflags}} | [STC/CMC](#stc-cmc)
<span markdown="0" id="x38">38</span> | {{danger}} | {NOP} | !!! | {{noflags}} | [Неопределенные инструкции](#undefined-instructions)
<span markdown="0" id="x39">39</span> | {{ alu16 }} | DAD SP | HL {{into}} HL + SP | {{noflags}} | [DAD](#dad)
<span markdown="0" id="x3a">3A</span> {2} {3} | {{mov8}} | LDA a16 | A {{into}} (a16) | {{noflags}} | [LDA](#lda-sta)
<span markdown="0" id="x3b">3B</span> | {{ alu16 }} | DCX SP | SP {{into}} SP - 1 | CY | [INX/DCX](#inx-dcx)
<span markdown="0" id="x3c">3C</span> | {{alu8}} | INR A | A {{into}} A + 1 | Z, S, P, AC | [INR/DCR](#inr-dcr)
<span markdown="0" id="x3d">3D</span> | {{alu8}} | DCR A | A {{into}} A - 1 | Z, S, P, AC | [INR/DCR](#inr-dcr)
<span markdown="0" id="x3e">3E</span> {2} | {{mov8}} | MVI A, d8 | A {{into}} {2} | {{noflags}} | [MVI](#mvi)
<span markdown="0" id="x3f">3F</span> | {{alu8}} | CMC | CY {{into}} !CY | {{noflags}} | [STC/CMC](#stc-cmc)
|---
<span markdown="0" id="x40">40</span> | {{mov8}} | MOV B, B {NOP} | B {{into}} B | {{noflags}} | [MOV](#mov)
<span markdown="0" id="x41">41</span> | {{mov8}} | MOV B, C | B {{into}} C | {{noflags}} | [MOV](#mov)
<span markdown="0" id="x42">42</span> | {{mov8}} | MOV B, D | B {{into}} D | {{noflags}} | [MOV](#mov)
<span markdown="0" id="x43">43</span> | {{mov8}} | MOV B, E | B {{into}} E | {{noflags}} | [MOV](#mov) 
<span markdown="0" id="x44">44</span> | {{mov8}} | MOV B, H | B {{into}} H | {{noflags}} | [MOV](#mov)
<span markdown="0" id="x45">45</span> | {{mov8}} | MOV B, L | B {{into}} L | {{noflags}} | [MOV](#mov)
<span markdown="0" id="x46">46</span> | {{mov8}} | MOV B, M | B {{into}} (HL) | {{noflags}} | [MOV](#mov)
<span markdown="0" id="x47">47</span> | {{mov8}} | MOV B, A | B {{into}} A | {{noflags}} | [MOV](#mov)
<span markdown="0" id="x48">48</span> | {{mov8}} | MOV C, B | C {{into}} B | {{noflags}} | [MOV](#mov)
<span markdown="0" id="x49">49</span> | {{mov8}} | MOV C, C {NOP} | C {{into}} C | {{noflags}} | [MOV](#mov)
<span markdown="0" id="x4a">4A</span> | {{mov8}} | MOV C, D | C {{into}} D | {{noflags}} | [MOV](#mov)
<span markdown="0" id="x4b">4B</span> | {{mov8}} | MOV C, E | C {{into}} E | {{noflags}} | [MOV](#mov)
<span markdown="0" id="x4c">4C</span> | {{mov8}} | MOV C, H | C {{into}} H | {{noflags}} | [MOV](#mov)
<span markdown="0" id="x4d">4D</span> | {{mov8}} | MOV C, L | C {{into}} L | {{noflags}} | [MOV](#mov)
<span markdown="0" id="x4e">4E</span> | {{mov8}} | MOV C, M | C {{into}} (HL) | {{noflags}} | [MOV](#mov)
<span markdown="0" id="x4f">4F</span> | {{mov8}} | MOV C, A | C {{into}} A | {{noflags}} | [MOV](#mov) 
|---
<span markdown="0" id="x50">50</span> | {{mov8}} | MOV D, B | D {{into}} B | {{noflags}} | [MOV](#mov) 
<span markdown="0" id="x51">51</span> | {{mov8}} | MOV D, C | D {{into}} C | {{noflags}} | [MOV](#mov) 
<span markdown="0" id="x52">52</span> | {{mov8}} | MOV D, D {NOP} | D {{into}} D | {{noflags}} | [MOV](#mov)
<span markdown="0" id="x53">53</span> | {{mov8}} | MOV D, E | D {{into}} E | {{noflags}} | [MOV](#mov)
<span markdown="0" id="x54">54</span> | {{mov8}} | MOV D, H | D {{into}} H | {{noflags}} | [MOV](#mov)
<span markdown="0" id="x55">55</span> | {{mov8}} | MOV D, L | D {{into}} L | {{noflags}} | [MOV](#mov)
<span markdown="0" id="x56">56</span> | {{mov8}} | MOV D, M | D {{into}} (HL) |  {{noflags}} | [MOV](#mov)
<span markdown="0" id="x57">57</span> | {{mov8}} | MOV D, A | D {{into}} A | {{noflags}} | [MOV](#mov)
<span markdown="0" id="x58">58</span> | {{mov8}} | MOV E, B | E {{into}} B | {{noflags}} | [MOV](#mov)
<span markdown="0" id="x59">59</span> | {{mov8}} | MOV E, C | E {{into}} C | {{noflags}} | [MOV](#mov)
<span markdown="0" id="x5a">5A</span> | {{mov8}} | MOV E, D | E {{into}} D | {{noflags}} | [MOV](#mov)
<span markdown="0" id="x5b">5B</span> | {{mov8}} | MOV E, E {NOP} | E {{into}} E |   {{noflags}} | [MOV](#mov)
<span markdown="0" id="x5c">5C</span> | {{mov8}} | MOV E, H | E {{into}} H | {{noflags}} | [MOV](#mov)
<span markdown="0" id="x5d">5D</span> | {{mov8}} | MOV E, L | E {{into}} L | {{noflags}} | [MOV](#mov)
<span markdown="0" id="x5e">5E</span> | {{mov8}} | MOV E, M | E {{into}} (HL) |  {{noflags}} | [MOV](#mov)
<span markdown="0" id="x5f">5F</span> | {{mov8}} | MOV E, A | E {{into}} A | {{noflags}} | [MOV](#mov)
|---
<span markdown="0" id="x60">60</span> | {{mov8}} | MOV H, B | H {{into}} B | {{noflags}} | [MOV](#mov)
<span markdown="0" id="x61">61</span> | {{mov8}} | MOV H, C | H {{into}} C | {{noflags}} | [MOV](#mov)
<span markdown="0" id="x62">62</span> | {{mov8}} | MOV H, D | H {{into}} D | {{noflags}} | [MOV](#mov)
<span markdown="0" id="x63">63</span> | {{mov8}} | MOV H, E | H {{into}} E | {{noflags}} | [MOV](#mov)
<span markdown="0" id="x64">64</span> | {{mov8}} | MOV H, H {NOP} | H {{into}} H | {{noflags}} | [MOV](#mov)
<span markdown="0" id="x65">65</span> | {{mov8}} | MOV H, L | H {{into}} L | {{noflags}} | [MOV](#mov)
<span markdown="0" id="x66">66</span> | {{mov8}} | MOV H, M | H {{into}} (HL) | {{noflags}} | [MOV](#mov)
<span markdown="0" id="x67">67</span> | {{mov8}} | MOV H, A | H {{into}} A | {{noflags}} | [MOV](#mov)
<span markdown="0" id="x68">68</span> | {{mov8}} | MOV L, B | L {{into}} B | {{noflags}} | [MOV](#mov)
<span markdown="0" id="x69">69</span> | {{mov8}} | MOV L, C | L {{into}} C | {{noflags}} | [MOV](#mov)
<span markdown="0" id="x6a">6A</span> | {{mov8}} | MOV L, D | L {{into}} D | {{noflags}} | [MOV](#mov)
<span markdown="0" id="x6b">6B</span> | {{mov8}} | MOV L, E | L {{into}} E | {{noflags}} | [MOV](#mov)
<span markdown="0" id="x6c">6C</span> | {{mov8}} | MOV L, H | L {{into}} H | {{noflags}} | [MOV](#mov)
<span markdown="0" id="x6d">6D</span> | {{mov8}} | MOV L, L {NOP} | L {{into}} L | {{noflags}} | [MOV](#mov)
<span markdown="0" id="x6e">6E</span> | {{mov8}} | MOV L, M | L {{into}} (HL) | {{noflags}} | [MOV](#mov)
<span markdown="0" id="x6f">6F</span> | {{mov8}} | MOV L, A | L {{into}} A | {{noflags}} | [MOV](#mov)
|---
<span markdown="0" id="x70">70</span> | {{mov8}} | MOV M, B | (HL) {{into}} B | {{noflags}} | [MOV](#mov)
<span markdown="0" id="x71">71</span> | {{mov8}} | MOV M, C | (HL) {{into}} C | {{noflags}} | [MOV](#mov)
<span markdown="0" id="x72">72</span> | {{mov8}} | MOV M, D | (HL) {{into}} D | {{noflags}} | [MOV](#mov)
<span markdown="0" id="x73">73</span> | {{mov8}} | MOV M, E | (HL) {{into}} E | {{noflags}} | [MOV](#mov)
<span markdown="0" id="x74">74</span> | {{mov8}} | MOV M, H | (HL) {{into}} H | {{noflags}} | [MOV](#mov)
<span markdown="0" id="x75">75</span> | {{mov8}} | MOV M, L | (HL) {{into}} L | {{noflags}} | [MOV](#mov)
<span markdown="0" id="x76">76</span> | {{control}} | HLT | Остановить процессор | {{noflags}} | [HLT](#hlt)
<span markdown="0" id="x77">77</span> | {{mov8}} | MOV M, A | (HL) {{into}} A | {{noflags}} | [MOV](#mov) 
<span markdown="0" id="x78">78</span> | {{mov8}} | MOV A, B | A {{into}} B | {{noflags}} | [MOV](#mov)
<span markdown="0" id="x79">79</span> | {{mov8}} | MOV A, C | A {{into}} C | {{noflags}} | [MOV](#mov)
<span markdown="0" id="x7a">7A</span> | {{mov8}} | MOV A, D | A {{into}} D | {{noflags}} | [MOV](#mov)
<span markdown="0" id="x7b">7B</span> | {{mov8}} | MOV A, E | A {{into}} E | {{noflags}} | [MOV](#mov)
<span markdown="0" id="x7c">7C</span> | {{mov8}} | MOV A, H | A {{into}} H | {{noflags}} | [MOV](#mov)
<span markdown="0" id="x7d">7D</span> | {{mov8}} | MOV A, L | A {{into}} L | {{noflags}} | [MOV](#mov)
<span markdown="0" id="x7e">7E</span> | {{mov8}} | MOV A, M | A {{into}} (HL) | {{noflags}} | [MOV](#mov)
<span markdown="0" id="x7f">7F</span> | {{mov8}} | MOV A, A {NOP} | A {{into}} A | {{noflags}} | [MOV](#mov)
|---
<span markdown="0" id="x80">80</span> | {{alu8}} | ADD B | A {{into}} A + B | Z, S, P, CY, AC | [ADD](#add)
<span markdown="0" id="x81">81</span> | {{alu8}} | ADD C | A {{into}} A + C | Z, S, P, CY, AC | [ADD](#add)
<span markdown="0" id="x82">82</span> | {{alu8}} | ADD D | A {{into}} A + D | Z, S, P, CY, AC | [ADD](#add)
<span markdown="0" id="x83">83</span> | {{alu8}} | ADD E | A {{into}} A + E | Z, S, P, CY, AC | [ADD](#add)
<span markdown="0" id="x84">84</span> | {{alu8}} | ADD H | A {{into}} A + H | Z, S, P, CY, AC | [ADD](#add)
<span markdown="0" id="x85">85</span> | {{alu8}} | ADD L | A {{into}} A + L | Z, S, P, CY, AC | [ADD](#add)
<span markdown="0" id="x86">86</span> | {{alu8}} | ADD M | A {{into}} A + (HL) | Z, S, P, CY, AC | [ADD](#add)
<span markdown="0" id="x87">87</span> | {{alu8}} | ADD A | A {{into}} A + A | Z, S, P, CY, AC | [ADD](#add)
<span markdown="0" id="x88">88</span> | {{alu8}} | ADC B | A {{into}} A + B + CY | Z, S, P, CY, AC | [ADC](#adc)
<span markdown="0" id="x89">89</span> | {{alu8}} | ADC C | A {{into}} A + C + CY | Z, S, P, CY, AC | [ADC](#adc)
<span markdown="0" id="x8a">8A</span> | {{alu8}} | ADC D | A {{into}} A + D + CY | Z, S, P, CY, AC | [ADC](#adc)
<span markdown="0" id="x8b">8B</span> | {{alu8}} | ADC E | A {{into}} A + E + CY | Z, S, P, CY, AC | [ADC](#adc)
<span markdown="0" id="x8c">8C</span> | {{alu8}} | ADC H | A {{into}} A + H + CY | Z, S, P, CY, AC | [ADC](#adc)
<span markdown="0" id="x8d">8D</span> | {{alu8}} | ADC L | A {{into}} A + L + CY | Z, S, P, CY, AC | [ADC](#adc)
<span markdown="0" id="x8e">8E</span> | {{alu8}} | ADC M | A {{into}} A + (HL) + CY | Z, S, P, CY, AC | [ADC](#adc)
<span markdown="0" id="x8f">8F</span> | {{alu8}} | ADC A | A {{into}} A + A + CY | Z, S, P, CY, AC | [ADC](#adc)
|---
<span markdown="0" id="x90">90</span> | {{alu8}} | SUB B | A {{into}} A - B | Z, S, P, CY, AC | [SUB](#sub)
<span markdown="0" id="x91">91</span> | {{alu8}} | SUB C | A {{into}} A - C | Z, S, P, CY, AC | [SUB](#sub)
<span markdown="0" id="x92">92</span> | {{alu8}} | SUB D | A {{into}} A - D | Z, S, P, CY, AC | [SUB](#sub)
<span markdown="0" id="x93">93</span> | {{alu8}} | SUB E | A {{into}} A - E | Z, S, P, CY, AC | [SUB](#sub)
<span markdown="0" id="x94">94</span> | {{alu8}} | SUB H | A {{into}} A - H | Z, S, P, CY, AC | [SUB](#sub)
<span markdown="0" id="x95">95</span> | {{alu8}} | SUB L | A {{into}} A - L | Z, S, P, CY, AC | [SUB](#sub)
<span markdown="0" id="x96">96</span> | {{alu8}} | SUB M | A {{into}} A - (HL) | Z, S, P, CY, AC | [SUB](#sub)
<span markdown="0" id="x97">97</span> | {{alu8}} | SUB A | A {{into}} A - A {A {{into}} 0}| Z, S, P, CY, AC | [SUB](#sub)
<span markdown="0" id="x98">98</span> | {{alu8}} | SBB B | A {{into}} A - B - CY | Z, S, P, CY, AC | [SBB](#sbb)
<span markdown="0" id="x99">99</span> | {{alu8}} | SBB C | A {{into}} A - C - CY | Z, S, P, CY, AC | [SBB](#sbb)
<span markdown="0" id="x9a">9A</span> | {{alu8}} | SBB D | A {{into}} A - D - CY | Z, S, P, CY, AC | [SBB](#sbb)
<span markdown="0" id="x9b">9B</span> | {{alu8}} | SBB E | A {{into}} A - E - CY | Z, S, P, CY, AC | [SBB](#sbb)
<span markdown="0" id="x9c">9C</span> | {{alu8}} | SBB H | A {{into}} A - H - CY | Z, S, P, CY, AC | [SBB](#sbb)
<span markdown="0" id="x9d">9D</span> | {{alu8}} | SBB L | A {{into}} A - L - CY | Z, S, P, CY, AC | [SBB](#sbb)
<span markdown="0" id="x9e">9E</span> | {{alu8}} | SBB M | A {{into}} A - (HL) - CY | Z, S, P, CY, AC | [SBB](#sbb)
<span markdown="0" id="x9f">9F</span> | {{alu8}} | SBB A | A {{into}} A - A - CY | Z, S, P, CY, AC | [SBB](#sbb)
|---
<span markdown="0" id="xa0">A0</span> | {{alu8}} | ANA B | A {{into}} A & B | Z, S, P, CY | [ANA](#ana)
<span markdown="0" id="xa1">A1</span> | {{alu8}} | ANA C | A {{into}} A & C | Z, S, P, CY | [ANA](#ana)
<span markdown="0" id="xa2">A2</span> | {{alu8}} | ANA D | A {{into}} A & D | Z, S, P, CY | [ANA](#ana)
<span markdown="0" id="xa3">A3</span> | {{alu8}} | ANA E | A {{into}} A & E | Z, S, P, CY | [ANA](#ana)
<span markdown="0" id="xa4">A4</span> | {{alu8}} | ANA H | A {{into}} A & H | Z, S, P, CY | [ANA](#ana) 
<span markdown="0" id="xa5">A5</span> | {{alu8}} | ANA L | A {{into}} A & L | Z, S, P, CY | [ANA](#ana)
<span markdown="0" id="xa6">A6</span> | {{alu8}} | ANA M | A {{into}} A & (HL) | Z, S, P, CY | [ANA](#ana)
<span markdown="0" id="xa7">A7</span> | {{alu8}} | ANA A | A {{into}} A & A {NOP} | Z, S, P, CY | [ANA](#ana)
<span markdown="0" id="xa8">A8</span> | {{alu8}} | XRA B | A {{into}} A ^ B | Z, S, P, CY, AC | [XRA](#xra)
<span markdown="0" id="xa9">A9</span> | {{alu8}} | XRA C | A {{into}} A ^ C | Z, S, P, CY, AC | [XRA](#xra)
<span markdown="0" id="xaa">AA</span> | {{alu8}} | XRA D | A {{into}} A ^ D | Z, S, P, CY, AC | [XRA](#xra)
<span markdown="0" id="xab">AB</span> | {{alu8}} | XRA E | A {{into}} A ^ E | Z, S, P, CY, AC | [XRA](#xra)
<span markdown="0" id="xac">AC</span> | {{alu8}} | XRA H | A {{into}} A ^ H | Z, S, P, CY, AC | [XRA](#xra)
<span markdown="0" id="xad">AD</span> | {{alu8}} | XRA L | A {{into}} A ^ L | Z, S, P, CY, AC | [XRA](#xra)
<span markdown="0" id="xae">AE</span> | {{alu8}} | XRA M | A {{into}} A ^ (HL) | Z, S, P, CY, AC | [XRA](#xra)
<span markdown="0" id="xaf">AF</span> | {{alu8}} | XRA A | A {{into}} A ^ A {A {{into}} 0} | Z, S, P, CY, AC | [XRA](#xra)
|---
<span markdown="0" id="xb0">B0</span> | {{alu8}} | ORA B | A {{into}} A \| B | Z, S, P, CY | [ORA](#ora)
<span markdown="0" id="xb1">B1</span> | {{alu8}} | ORA C | A {{into}} A \| C | Z, S, P, CY | [ORA](#ora)
<span markdown="0" id="xb2">B2</span> | {{alu8}} | ORA D | A {{into}} A \| D | Z, S, P, CY | [ORA](#ora)
<span markdown="0" id="xb3">B3</span> | {{alu8}} | ORA E | A {{into}} A \| E | Z, S, P, CY | [ORA](#ora)
<span markdown="0" id="xb4">B4</span> | {{alu8}} | ORA H | A {{into}} A \| H | Z, S, P, CY | [ORA](#ora)
<span markdown="0" id="xb5">B5</span> | {{alu8}} | ORA L | A {{into}} A \| L | Z, S, P, CY | [ORA](#ora)
<span markdown="0" id="xb6">B6</span> | {{alu8}} | ORA M | A {{into}} A \| (HL) | Z, S, P, CY | [ORA](#ora)
<span markdown="0" id="xb7">B7</span> | {{alu8}} | ORA A | A {{into}} A \| A {NOP} | Z, S, P, CY | [ORA](#ora)
<span markdown="0" id="xb8">B8</span> | {{alu8}} | CMP B | &empty; {{into}} A - B | Z, S, P, CY, AC | [CMP](#cmp)
<span markdown="0" id="xb9">B9</span> | {{alu8}} | CMP C | &empty; {{into}} A - C | Z, S, P, CY, AC | [CMP](#cmp)
<span markdown="0" id="xba">BA</span> | {{alu8}} | CMP D | &empty; {{into}} A - D | Z, S, P, CY, AC | [CMP](#cmp)
<span markdown="0" id="xbb">BB</span> | {{alu8}} | CMP E | &empty; {{into}} A - E | Z, S, P, CY, AC | [CMP](#cmp)
<span markdown="0" id="xbc">BC</span> | {{alu8}} | CMP H | &empty; {{into}} A - H | Z, S, P, CY, AC | [CMP](#cmp)
<span markdown="0" id="xbd">BD</span> | {{alu8}} | CMP L | &empty; {{into}} A - L | Z, S, P, CY, AC | [CMP](#cmp)
<span markdown="0" id="xbe">BE</span> | {{alu8}} | CMP M | &empty; {{into}} A - (HL) | Z, S, P, CY, AC | [CMP](#cmp)
<span markdown="0" id="xbf">BF</span> | {{alu8}} | CMP A | &empty; {{into}} A - A | Z, S, P, CY, AC | [CMP](#cmp)
|---
<span markdown="0" id="xc0">C0</span> | {{jumps}} | RNZ | если не Z, PC {{into}} POP() | {{noflags}} | [RET](#ret)
<span markdown="0" id="xc1">C1</span> | {{ mov16 }} | POP B | BC {{into}} POP() | {{noflags}} | [PUSH/POP](#push-pop)
<span markdown="0" id="xc2">C2</span> {2} {3} | {{jumps}} | JNZ a16 | если не Z, PC {{into}} a16 | {{noflags}} | [JMP](#jmp)
<span markdown="0" id="xc3">C3</span> {2} {3} | {{jumps}} | JMP a16 | PC {{into}} a16 | {{noflags}} | [JMP](#jmp)
<span markdown="0" id="xc4">C4</span> {2} {3} | {{jumps}} | CNZ a16 | если не Z, PUSH(PC) и PC {{into}} a16 | {{noflags}} | [CALL](#call)
<span markdown="0" id="xc5">C5</span> | {{mov16}} | PUSH B | PUSH(BC) | {{noflags}} | [PUSH/POP](#push-pop)
<span markdown="0" id="xc6">C6</span> {2} | {{alu8}} | ADI d8 | A {{into}} A + {2} | Z, S, P, CY, AC | [ADD](#add)
<span markdown="0" id="xc7">C7</span> | {{jumps}} | RST 0 | PUSH(PC) и PC {{into}} 0x0000 | {{noflags}} | [RST](#rst)
<span markdown="0" id="xc8">C8</span> | {{jumps}} | RZ | если Z, PC {{into}} POP() | {{noflags}} | [RET](#ret)
<span markdown="0" id="xc9">C9</span> | {{jumps}} | RET | PC {{into}} POP() | {{noflags}} | [RET](#ret)
<span markdown="0" id="xca">CA</span> {2} {3} | {{jumps}} | JZ a16 | если Z, PC {{into}} a16 | {{noflags}} | [JMP](#jmp)
<span markdown="0" id="xcb">CB</span> {2} {3} | {{danger}} | {JMP a16} | !!! | {{noflags}} | [Неопределенные инструкции](#undefined-instructions)
<span markdown="0" id="xcc">CC</span> {2} {3} | {{jumps}} | CZ a16 | если Z, PUSH(PC) и PC {{into}} a16 | {{noflags}} | [CALL](#call)
<span markdown="0" id="xcd">CD</span> {2} {3} | {{jumps}} | CALL a16 | PUSH(PC) и PC {{into}} a16 | {{noflags}} | [CALL](#call)
<span markdown="0" id="xce">CE</span> {2} | {{alu8}} | ACI d8 | A {{into}} A + {2} + CY | Z, S, P, CY, AC | [Immediate-арифметика](#alu8-immediate)
<span markdown="0" id="xcf">CF</span> | {{jumps}} | RST 1 | PUSH(PC) и PC {{into}} 0x0008 | {{noflags}} | [RST](#rst)
|---
<span markdown="0" id="xd0">D0</span> | {{jumps}} | RNC | если не CY, PC {{into}} POP() | {{noflags}} | [RET](#ret)
<span markdown="0" id="xd1">D1</span> | {{ mov16 }} | POP D | DE {{into}} POP() | {{noflags}} | [PUSH/POP](#push-pop)
<span markdown="0" id="xd2">D2</span> {2} {3} | {{jumps}} | JNC a16 | если не CY, PC {{into}} a16 | {{noflags}} | [JMP](#jmp)
<span markdown="0" id="xd3">D3</span> {2} | {{control}} | OUT d8 | если не CY, выводим A в порт {2} | {{noflags}} | [IN/OUT](#in-out)
<span markdown="0" id="xd4">D4</span> {2} {3} | {{jumps}} | CNC a16 | если не CY, PUSH(PC) и PC {{into}} a16 | {{noflags}} | [CALL](#call)
<span markdown="0" id="xd5">D5</span> | {{mov16}} | PUSH D | PUSH(DE) | {{noflags}} | [PUSH/POP](#push-pop)
<span markdown="0" id="xd6">D6</span> {2} | {{alu8}} | SUI d8 | A {{into}} A - {2} | Z, S, P, CY, AC | [Immmediate-арифметика](#alu8-immediate)
<span markdown="0" id="xd7">D7</span> | {{jumps}} | RST 2 | PUSH(PC) и PC {{into}} 0x0010 | {{noflags}} | [RST](#rst)
<span markdown="0" id="xd8">D8</span> | {{jumps}} | RC | если не CY, PC {{into}} POP() | {{noflags}} | [RET](#ret)
<span markdown="0" id="xd9">D9</span> | {{danger}} | {RET} | !!! | {{noflags}} | [Неопределенные инструкции](#undefined-instructions)
<span markdown="0" id="xda">DA</span> {2} {3} | {{jumps}} | JC a16 | если CY, PC {{into}} a16 | {{noflags}} | [JMP](#jmp)
<span markdown="0" id="xdb">DB</span> {2} {3} | {{control}} | IN d8 | считываем значение в A из порта {2} | {{noflags}} | [IN/OUT](#in-out)
<span markdown="0" id="xdc">DC</span> {2} {3} | {{jumps}} | CC a16 | если CY, PUSH(PC) и PC {{into}} a16 | {{noflags}} | [CALL](#call)
<span markdown="0" id="xdd">DD</span> {2} {3} | {{danger}} | {CALL d16} | !!! | {{noflags}} | [Неопределенные инструкции](#undefined-instructions)
<span markdown="0" id="xde">DE</span> {2} | {{alu8}} | SBI d8 | A {{into}} A - {2} - CY | Z, S, P, CY, AC | [Immediate-арифметика](#alu8-immediate)
<span markdown="0" id="xdf">DF</span> | {{jumps}} | RST 3 | PUSH(PC) и PC {{into}} 0x0018 | {{noflags}} | [RST](#rst)
|---
<span markdown="0" id="xe0">E0</span> {2} {3} | {{jumps}} | RPO | если не P, PC {{into}} POP() | {{noflags}} | [RET](#ret)
<span markdown="0" id="xe1">E1</span> | {{ mov16 }} | POP H | HL {{into}} POP() | {{noflags}} | [PUSH/POP](#push-pop)
<span markdown="0" id="xe2">E2</span> {2} {3} | {{jumps}} | JPO a16 | если не P, PC {{into}} a16 | {{noflags}} | [JMP](#jmp)
<span markdown="0" id="xe3">E3</span> {2} {3} | {{ mov16 }} | XTHL | tmp1 {{into}} (SP); tmp2 {{into}} (SP+1); (SP) {{into}} L; (SP+1) {{into}} H; H {{into}} tmp1; L {{into}} tmp2 | {{noflags}} | [XTHL](#xthl)
<span markdown="0" id="xe4">E4</span> {2} {3} | {{jumps}} | CPO a16 | если не P, PUSH(PC) и PC {{into}} a16 | {{noflags}} | [CALL](#call)
<span markdown="0" id="xe5">E5</span> | {{mov16}} | PUSH H | PUSH(HL) | {{noflags}} | [PUSH/POP](#push-pop)
<span markdown="0" id="xe6">E6</span> {2} | {{alu8}} | ANI d8 | A {{into}} A & {2} | Z, S, P, CY, AC | [Immediate-арифметика](#alu8-immediate)
<span markdown="0" id="xe7">E7</span> | {{jumps}} | RST 4 | PUSH(PC) и PC {{into}} 0x0020 | {{noflags}} | [RST](#rst)
<span markdown="0" id="xe8">E8</span> | {{jumps}} | RPE | если P, PC {{into}} POP() | {{noflags}} | [RET](#ret)
<span markdown="0" id="xe9">E9</span> | {{jumps}} | PCHL | PC {{into}} HL {JMP HL} | {{noflags}} | [JMP](#jmp)
<span markdown="0" id="xea">EA</span> {2} {3} | {{jumps}} | JPE a16 | если P, PC {{into}} a16 | {{noflags}} | [JMP](#jmp)
<span markdown="0" id="xeb">EB</span> {2} {3} | {{ mov16 }} | XCHG | tmp {{into}} DE; DE {{into}} HL; HL {{into}} tmp | {{noflags}} | [XCHG](#xchg)
<span markdown="0" id="xec">EC</span> {2} {3} | {{jumps}} | CPE a16 | если P, PUSH(PC) и PC {{into}} a16 | {{noflags}} | [CALL](#call)
<span markdown="0" id="xed">ED</span> {2} {3} | {{danger}} | {CALL d16} | !!! | {{noflags}} | [Неопределенные инструкции](#undefined-instructions)
<span markdown="0" id="xee">EE</span> {2} | {{alu8}} | XRI d8 | A {{into}} A ^ {2} | Z, S, P, CY, AC | [Immediate-арифметика](#alu8-immediate)
<span markdown="0" id="xef">EF</span> | {{jumps}} | RST 5 | PUSH(PC) и PC {{into}} 0x0028 | {{noflags}} | [RST](#rst)
|---
<span markdown="0" id="xf0">F0</span> {2} {3} | {{jumps}} | RP | если не S, PC {{into}} POP() | {{noflags}} | [RET](#ret)
<span markdown="0" id="xf1">F1</span> | {{ mov16 }} | POP PSW | AF {{into}} POP() | Z, S, P, CY, AC | [PUSH/POP](#push-pop)
<span markdown="0" id="xf2">F2</span> {2} {3} | {{jumps}} | JP a16 | если не S, PC {{into}} a16 | {{noflags}} | [JMP](#jmp)
<span markdown="0" id="xf3">F3</span> {2} {3} | {{control}} | DI | выключаем систему прирываний (INTE {{into}} 0) | {{noflags}} | [DI/EI](#di-ei)
<span markdown="0" id="xf4">F4</span> {2} {3} | {{jumps}} | CP a16 | если не S, PUSH(PC) и PC {{into}} a16 | {{noflags}} | [CALL](#call)
<span markdown="0" id="xf5">F5</span> | {{ mov16 }} | PUSH PSW | PUSH(AF) | {{noflags}} | [PUSH/POP](#push-pop)
<span markdown="0" id="xf6">F6</span> {2} | {{alu8}} | ORI d8 | A {{into}} A \| {2} | Z, S, P, CY, AC | [Immediate-арифметика](#alu8-immediate)
<span markdown="0" id="xf7">F7</span> | {{jumps}} | RST 6 | PUSH(PC) и PC {{into}} 0x0030 | {{noflags}} | [RST](#rst)
<span markdown="0" id="xf8">F8</span> {2} {3} | {{jumps}} | RM | если не S, PC {{into}} POP() | {{noflags}} | [RET](#ret)
<span markdown="0" id="xf9">F9</span> | {{ mov16 }} | SPHL | SP {{into}} HL | {{noflags}} | [SPHL](#sphl)
<span markdown="0" id="xfa">FA</span> {2} {3} | {{jumps}} | JM a16 | если S, PC {{into}} a16 | {{noflags}} | [JMP](#jmp)
<span markdown="0" id="xfb">FB</span> {2} {3} | {{control}} | EI | включаем систему прирываний (INTE {{into}} 1) | {{noflags}} | [DI/EI](#di-ei)
<span markdown="0" id="xfc">FC</span> {2} {3} | {{jumps}} | CM a16 | если S, PUSH(PC) и PC {{into}} a16 | {{noflags}} | [CALL](#call)
<span markdown="0" id="xfd">FD</span> {2} {3} | {{danger}} | {CALL d16} | !!! | {{noflags}} | [Неопределенные инструкции](#undefined-instructions)
<span markdown="0" id="xfe">FE</span> {2} | {{alu8}} | CPI d8 | &empty; {{into}} A - {2} | Z, S, P, CY, AC | [Immediate-арифметика](#alu8-immediate)
<span markdown="0" id="xff">FF</span> | {{jumps}} | RST 7 | PUSH(PC) и PC {{into}} 0x0038 | {{noflags}} | [RST](#rst)
|===
Опкод (hex) | Категория | Мнемоника | Краткое описание  | Затронутые флаги | Ссылка на описание |
--------------------------|----------|------------|-------------------|------------------|-------------------|
{: id="opcodes"}

# Таблица опкодов

<style markdown="0">
  .bytetable {
    width: 95%;
    margin: 0 auto;
    text-align: center;
    white-space: pre-line;
  } 
  .breakout {
    /* Expand outside of main container: https://stackoverflow.com/a/37964247/5936187 */
    margin:1em -100%; /* old browsers fallback */
    margin:1em calc(50% - 50vw);
  }

  .bytetable span.icon {
    font-size: x-large;
    break-after: always;
  }
  .bytetable span.icon:after {
      content:"\000A";
      white-space: pre;
  }
</style>

<div class="breakout" markdown="1">
| -- | x0                          | x1                              | x2                            | x3                            | x4                           | x5                            | x6                           | x7                          | x8                          | x9                          | xA                            | xB                           | xC                           | xD                            | xE                           | xF                          |
|---:|-----------------------------|---------------------------------|-------------------------------|-------------------------------|------------------------------|-------------------------------|------------------------------|-----------------------------|-----------------------------|-----------------------------|-------------------------------|------------------------------|------------------------------|-------------------------------|------------------------------|-----------------------------|
| 0x | [{{Hcontrol}} `NOP`](#x00)  | [{{Hmov16}} `LXI B,d16`](#x01)  | [{{Hmov8}} `STAX B`](#x02)    | [{{Halu16}} `INX B`](#x03)    | [{{Halu8}} `INR B`](#x04)    | [{{Halu8}} `DCR B`](#x05)     | [{{Hmov8}} `MVI B,d8`](#x06) | [{{Halu8}} `RLC`](#x07)     | [{{Hdanger}}](#x08)         | [{{Halu16}} `DAD B`](#x09)  | [{{Hmov16}} `LDAX B`](#x0a)   | [{{Halu16}} `DCX B`](#x0b)   | [{{Halu8}} `INR C`](#x0c)    | [{{Halu8}} `DCR C`](#x0d)     | [{{Hmov8}} `MVI C,d8`](#x0e) | [{{Halu8}} `RRC`](#x0f)     |
| 1x | [{{Hdanger}}](#x10)         | [{{Hmov16}} `LXI D,d16`](#x11)  | [{{Hmov8}} `STAX D`](#x12)    | [{{Halu16}} `INX D`](#x13)    | [{{Halu8}} `INR D`](#x14)    | [{{Halu8}} `DCR D`](#x15)     | [{{Hmov8}} `MVI D,d8`](#x16) | [{{Halu8}} `RAL`](#x17)     | [{{Hdanger}}](#x18)         | [{{Halu16}} `DAD D`](#x19)  | [{{Hmov16}} `LDAX D`](#x1a)   | [{{Halu16}} `DCX D`](#x1b)   | [{{Halu8}} `INR E`](#x1c)    | [{{Halu8}} `DCR E`](#x1d)     | [{{Hmov8}} `MVI E,d8`](#x1e) | [{{Halu8}} `RAR`](#x1f)     |
| 2x | [{{Hdanger}}](#x20)         | [{{Hmov16}} `LXI H,d16`](#x21)  | [{{Hmov16}} `SHLD a16`](#x22) | [{{Halu16}} `INX H`](#x23)    | [{{Halu8}} `INR H`](#x24)    | [{{Halu8}} `DCR H`](#x25)     | [{{Hmov8}} `MVI H,d8`](#x26) | [{{Halu8}} `DAA`](#x27)     | [{{Hdanger}}](#x28)         | [{{Halu16}} `DAD H`](#x29)  | [{{Hmov16}} `LHLD a16`](#x2a) | [{{Halu16}} `DCX H`](#x2b)   | [{{Halu8}} `INR L`](#x2c)    | [{{Halu8}} `DCR L`](#x2d)     | [{{Hmov8}} `MVI L,d8`](#x2e) | [{{Halu8}} `CMA`](#x2f)     |
| 3x | [{{Hdanger}}](#x30)         | [{{Hmov16}} `LXI SP,d16`](#x31) | [{{Hmov8}} `STA a16`](#x32)   | [{{Halu16}} `INX M`](#x33)    | [{{Halu8}} `INR M`](#x34)    | [{{Halu8}} `DCR M`](#x35)     | [{{Hmov8}} `MVI M,d8`](#x36) | [{{Halu8}} `STC`](#x37)     | [{{Hdanger}}](#x38)         | [{{Halu16}} `DAD SP`](#x39) | [{{Hmov16}} `LDA a16`](#x3a)  | [{{Halu16}} `DCX SP`](#x3b)  | [{{Halu8}} `INR A`](#x3c)    | [{{Halu8}} `DCR A`](#x3d)     | [{{Hmov8}} `MVI A,d8`](#x3e) | [{{Halu8}} `CMC`](#x3f)     |
| 4x | [{{Hmov8}} `MOV B,B`](#x40) | [{{Hmov8}} `MOV B,C`](#x41)     | [{{Hmov8}} `MOV B,D`](#x42)   | [{{Hmov8}} `MOV B,E`](#x43)   | [{{Hmov8}} `MOV B,H`](#x44)  | [{{Hmov8}} `MOV B,L`](#x45)   | [{{Hmov8}} `MOV B,M`](#x46)  | [{{Hmov8}} `MOV B,A`](#x47) | [{{Hmov8}} `MOV B,B`](#x48) | [{{Hmov8}} `MOV C,C`](#x49) | [{{Hmov8}} `MOV C,D`](#x4a)   | [{{Hmov8}} `MOV C,E`](#x4b)  | [{{Hmov8}} `MOV C,H`](#x4c)  | [{{Hmov8}} `MOV C,L`](#x4d)   | [{{Hmov8}} `MOV C,M`](#x4e)  | [{{Hmov8}} `MOV C,A`](#x4f) |
| 5x | [{{Hmov8}} `MOV D,B`](#x50) | [{{Hmov8}} `MOV D,C`](#x51)     | [{{Hmov8}} `MOV D,D`](#x52)   | [{{Hmov8}} `MOV D,E`](#x53)   | [{{Hmov8}} `MOV D,H`](#x54)  | [{{Hmov8}} `MOV D,L`](#x55)   | [{{Hmov8}} `MOV D,M`](#x56)  | [{{Hmov8}} `MOV D,A`](#x57) | [{{Hmov8}} `MOV D,B`](#x58) | [{{Hmov8}} `MOV E,C`](#x59) | [{{Hmov8}} `MOV E,D`](#x5a)   | [{{Hmov8}} `MOV E,E`](#x5b)  | [{{Hmov8}} `MOV E,H`](#x5c)  | [{{Hmov8}} `MOV E,L`](#x5d)   | [{{Hmov8}} `MOV E,M`](#x5e)  | [{{Hmov8}} `MOV E,A`](#x5f) |
| 6x | [{{Hmov8}} `MOV H,B`](#x60) | [{{Hmov8}} `MOV H,C`](#x61)     | [{{Hmov8}} `MOV H,D`](#x62)   | [{{Hmov8}} `MOV H,E`](#x63)   | [{{Hmov8}} `MOV H,H`](#x64)  | [{{Hmov8}} `MOV H,L`](#x65)   | [{{Hmov8}} `MOV H,M`](#x66)  | [{{Hmov8}} `MOV H,A`](#x67) | [{{Hmov8}} `MOV H,B`](#x68) | [{{Hmov8}} `MOV L,C`](#x69) | [{{Hmov8}} `MOV L,D`](#x6a)   | [{{Hmov8}} `MOV L,E`](#x6b)  | [{{Hmov8}} `MOV L,H`](#x6c)  | [{{Hmov8}} `MOV L,L`](#x6d)   | [{{Hmov8}} `MOV L,M`](#x6e)  | [{{Hmov8}} `MOV L,A`](#x6f) |
| 7x | [{{Hmov8}} `MOV M,B`](#x70) | [{{Hmov8}} `MOV M,C`](#x71)     | [{{Hmov8}} `MOV M,D`](#x72)   | [{{Hmov8}} `MOV M,E`](#x73)   | [{{Hmov8}} `MOV M,H`](#x74)  | [{{Hmov8}} `MOV M,L`](#x75)   | [{{Hcontrol}} `HLT`](#x76)   | [{{Hmov8}} `MOV M,A`](#x77) | [{{Hmov8}} `MOV M,B`](#x78) | [{{Hmov8}} `MOV A,C`](#x79) | [{{Hmov8}} `MOV A,D`](#x7a)   | [{{Hmov8}} `MOV A,E`](#x7b)  | [{{Hmov8}} `MOV A,H`](#x7c)  | [{{Hmov8}} `MOV A,L`](#x7d)   | [{{Hmov8}} `MOV A,M`](#x7e)  | [{{Hmov8}} `MOV A,A`](#x7f) |
| 8x | [{{Halu8}} `ADD B`](#x80)   | [{{Halu8}} `ADD C`](#x81)       | [{{Halu8}} `ADD D`](#x82)     | [{{Halu8}} `ADD E`](#x83)     | [{{Halu8}} `ADD H`](#x84)    | [{{Halu8}} `ADD L`](#x85)     | [{{Halu8}} `ADD M`](#x86)    | [{{Halu8}} `ADD A`](#x87)   | [{{Halu8}} `ADC B`](#x88)   | [{{Halu8}} `ADC C`](#x89)   | [{{Halu8}} `ADC D`](#x8a)     | [{{Halu8}} `ADC E`](#x8b)    | [{{Halu8}} `ADC H`](#x8c)    | [{{Halu8}} `ADC L`](#x8d)     | [{{Halu8}} `ADC M`](#x8e)    | [{{Halu8}} `ADC A`](#x8f)   |
| 9x | [{{Halu8}} `SUB B`](#x90)   | [{{Halu8}} `SUB C`](#x91)       | [{{Halu8}} `SUB D`](#x92)     | [{{Halu8}} `SUB E`](#x93)     | [{{Halu8}} `SUB H`](#x94)    | [{{Halu8}} `SUB L`](#x95)     | [{{Halu8}} `SUB M`](#x96)    | [{{Halu8}} `SUB A`](#x97)   | [{{Halu8}} `SBB B`](#x98)   | [{{Halu8}} `SBB C`](#x99)   | [{{Halu8}} `SBB D`](#x9a)     | [{{Halu8}} `SBB E`](#x9b)    | [{{Halu8}} `SBB H`](#x9c)    | [{{Halu8}} `SBB L`](#x9d)     | [{{Halu8}} `SBB M`](#x9e)    | [{{Halu8}} `SBB A`](#x9f)   |
| Ax | [{{Halu8}} `ANA B`](#xa0)   | [{{Halu8}} `ANA C`](#xa1)       | [{{Halu8}} `ANA D`](#xa2)     | [{{Halu8}} `ANA E`](#xa3)     | [{{Halu8}} `ANA H`](#xa4)    | [{{Halu8}} `ANA L`](#xa5)     | [{{Halu8}} `ANA M`](#xa6)    | [{{Halu8}} `ANA A`](#xa7)   | [{{Halu8}} `XRA B`](#xa8)   | [{{Halu8}} `XRA C`](#xa9)   | [{{Halu8}} `XRA D`](#xaa)     | [{{Halu8}} `XRA E`](#xab)    | [{{Halu8}} `XRA H`](#xac)    | [{{Halu8}} `XRA L`](#xad)     | [{{Halu8}} `XRA M`](#xae)    | [{{Halu8}} `XRA A`](#xaf)   |
| Bx | [{{Halu8}} `ORA B`](#xb0)   | [{{Halu8}} `ORA C`](#xb1)       | [{{Halu8}} `ORA D`](#xb2)     | [{{Halu8}} `ORA E`](#xb3)     | [{{Halu8}} `ORA H`](#xb4)    | [{{Halu8}} `ORA L`](#xb5)     | [{{Halu8}} `ORA M`](#xb6)    | [{{Halu8}} `ORA A`](#xb7)   | [{{Halu8}} `CMP B`](#xb8)   | [{{Halu8}} `CMP C`](#xb9)   | [{{Halu8}} `CMP D`](#xba)     | [{{Halu8}} `CMP E`](#xbb)    | [{{Halu8}} `CMP H`](#xbc)    | [{{Halu8}} `CMP L`](#xbd)     | [{{Halu8}} `CMP M`](#xbe)    | [{{Halu8}} `CMP A`](#xbf)   |
| Cx | [{{Hjumps}} `RNZ`](#xc0)    | [{{Hmov16}} `POP B`](#xc1)      | [{{Hjumps}} `JNZ a16`](#xc2)  | [{{Hjumps}} `JMP a16`](#xc3)  | [{{Hjumps}} `CNZ a16`](#xc4) | [{{Hmov16}} `PUSH B`](#xc5)   | [{{Halu8}} `ADI d8`](#xc6)   | [{{Hjumps}} `RST 0`](#xc7)  | [{{Hjumps}} `RZ`](#xc8)     | [{{Hjumps}} `RET`](#xc9)    | [{{Hjumps}} `JZ a16`](#xca)   | [{{Hdanger}}](#xcb)          | [{{Hjumps}} `CZ a16`](#xcc)  | [{{Hjumps}} `CALL a16`](#xcd) | [{{Halu8}} `ACI d8`](#xce)   | [{{Hjumps}} `RST 1`](#xcf)  |
| Dx | [{{Hjumps}} `RNC`](#xd0)    | [{{Hmov16}} `POP D`](#xd1)      | [{{Hjumps}} `JNC a16`](#xd2)  | [{{Hcontrol}} `OUT d8`](#xd3) | [{{Hjumps}} `CNC a16`](#xd4) | [{{Hmov16}} `PUSH D`](#xd5)   | [{{Halu8}} `SUI d8`](#xd6)   | [{{Hjumps}} `RST 2`](#xd7)  | [{{Hjumps}} `RC`](#xd8)     | [{{Hdanger}}](#xd9)         | [{{Hjumps}} `JC a16`](#xda)   | [{{Hcontrol}} `IN d8`](#xdb) | [{{Hjumps}} `CC a16`](#xdc)  | [{{Hdanger}}](#xdd)           | [{{Halu8}} `SBI d8`](#xde)   | [{{Hjumps}} `RST 3`](#xdf)  |
| Ex | [{{Hjumps}} `RPO`](#xe0)    | [{{Hmov16}} `POP H`](#xe1)      | [{{Hjumps}} `JPO a16`](#xe2)  | [{{Hmov16}} `XTHL`](#xe3)     | [{{Hjumps}} `CPO a16`](#xe4) | [{{Hmov16}} `PUSH H`](#xe5)   | [{{Halu8}} `ANI d8`](#xe6)   | [{{Hjumps}} `RST 4`](#xe7)  | [{{Hjumps}} `RPE`](#xe8)    | [{{Hjumps}} `PCHL`](#xe9)   | [{{Hjumps}} `JPE a16`](#xea)  | [{{Hmov16}} `XCHG`](#xeb)    | [{{Hjumps}} `CPE a16`](#xec) | [{{Hdanger}}](#xed)           | [{{Halu8}} `XRI d8`](#xee)   | [{{Hjumps}} `RST 5`](#xef)  |
| Fx | [{{Hjumps}} `RP`](#xf0)     | [{{Hmov16}} `POP PSW`](#xf1)    | [{{Hjumps}} `JP a16`](#xf2)   | [{{Hcontrol}} `DI`](#xf3)     | [{{Hjumps}} `CP a16`](#xf4)  | [{{Hmov16}} `PUSH PSW`](#xf5) | [{{Halu8}} `ORI d8`](#xf5)   | [{{Hjumps}} `RST 6`](#xf6)  | [{{Hjumps}} `RM`](#xf8)     | [{{Hmov16}} `SPHL`](#xf9)   | [{{Hjumps}} `JM a16`](#xfa)   | [{{Hcontrol}} `EI`](#xfb)    | [{{Hjumps}} `CM a16`](#xfc)  | [{{Hdanger}}](#xfd)           | [{{Halu8}} `CPI d8`](#xfe)   | [{{Hjumps}} `RST 7`](#xff)  |
{: .bytetable }
</div>

# Инструкции
{: #categories }

У процессора есть несколко категорий команд:

- [{{ control }} Управление процессором](#control)
- [{{ jumps }} Переходы и вызовы](#jumps)
- [{{ mov8 }} Загрузка, сохранение и перемещение, 8-бит](#mov8)
- [{{ mov16 }} Загрузка, сохранение и перемещение, 16-бит](#mov16)
- [{{ alu8 }} Арифметические и логические операции, 8-бит](#alu8)
- [{{ alu16 }} Арифметические и логические операции, 16-бит](#alu16)

{% assign up="&#x2b06;" %}{% comment %}U+2B06 UP ARROW{% endcomment %}
{% assign down="&#x2193;" %}{% comment %}U+2193 DOWN ARROW{% endcomment %}
{% assign left="&#x2190;" %}{% comment %}U+2190 LEFT ARROW{% endcomment %}
{% assign right="&#x2192;" %}{% comment %}U+2192 RIGHT ARROW{% endcomment %}



## {{ control }} Управление процессором 
{: #control }

[{{up}} Вернуться к категориям инструкций](#categories)

Эти инструкции отвечают за операции, которые нельзя отнести к другим категориям.
Они редко используются при написании прикладных программ, и больше относятся к разработке системы.

### NOP

[{{up}} Вернуться к инструкциям управления процессором](#control)

Выполнение инструкции `NOP` не изменяет ничего.

Опкод инструкции `NOP` равен `0x00`, что значит, что по умолчанию память эмулятора СМ-1800 полностью заполнена `NOP`-инструкциями.
Это значит, что если выполнять код в незаданной памяти, то процессор будет выполнять инструкции `NOP`, пока не дойдет до какого-то другого кода.

{% capture sample %}
```asm
; Не делать ничего
NOP
```
{% endcapture %}
{% include code-sample.html content=sample %}

### HLT

[{{up}} Вернуться к инструкциям управления процессором](#control)

Инструкция `HLT` останавливает выполнение процессора.

После выполнения этой инструкции процессор входит в состояние, в котором выполнение кода прекращается до получения внешнего прерывания.
Если внешнее прерывание получено, то процессор считывает с линий данных один байт инструкции (обычно это одна из [RST-инструкций](#rst)) и выполняет её.
[{{up}} Вернуться к инструкциям перемещения, 8-бит](#mov8)

{% capture sample %}
```asm
; Остановить выполнение навсегда
DI
HLT
```
{% endcapture %}
{% include code-sample.html content=sample %}

### IN/OUT
{: #in-out }

[{{up}} Вернуться к инструкциям управления процессором](#control)

Инструкции `IN d8` и `OUT d8` используются для того, чтобы передавать данные во внешний порт или принимать данные из внешнего порта.
Какой именно смысл имеют эти порты, зависит от конкретного оборудования вокруг процессора.
Для систем, в которых есть системные вызовы (вроде СМ-1800), чаще всего следует не использовать эти инструкции самому, а вместо этого вызывать системные подпрограммы для выполнения таких задач.

На аппаратном уровне [можно считать, что у Intel 8080 на самом деле 17-битная адресная шина](https://stackoverflow.com/a/13750889/5936187), где верхняя линия -- это `IORQ`, которая равна 0 при обычной работе с памятью и 1 при выполнении `IN` и `OUT`.

При выполнении `OUT`, нижние 8 бит адресной шины устанавливаются в значение, переданное как аргумент инструкции. После этого процессор выдает значение A на линию данных, и внешнее оборудование может прочитать его оттуда.

При выполнении `IN`, нижние 8 бит устанавливаются в значение аргумента инструкции. После этого внешнее оборудование должно передать значение в процессор на линию данных, которое процессор принимает и записывает в регистр A.


{% capture sample %}
```asm
; Передать значение 0x55 в порт 0xC3
MVI A, 0x55
OUT 0xC3

; Читать значение из порта 0xA2
IN 0xA2
```
{% endcapture %}
{% include code-sample.html content=sample %}

### DI/EI
{: #di-ei }

[{{up}} Вернуться к инструкциям управления процессором](#control)

Пара инструкций `DI` и `EI` используется для управления прерываниями. `DI` (*disable interrupts*) выключает прерывания, а `EI` (*enable interrupts*) включает их.

Прерывания -- это способ позволить оборудованию вокруг процессора останавливать выполнение основной программы и вместо этого делать некое действие в ответ на внешнее событие.

Прерывания [работают следующим образом](https://stackoverflow.com/a/26197699/5936187): если внешнее оборудование хочет вызвать прерывание, то подается сигнал на линию прерываний.
Когда процессор завершает текущую инструкцию, он подтверждает, что получил прерывание.
После этого внешнее оборудование должно подать на линию данных инструкцию из одного байта -- чаще всего это одна из [`RST`-инструкций](#rst).

После того, как прерывание произошло и было обработано, прерывания выключаются, поэтому если нужно обрабатывать последующие прерывания, то нужно включить их еще раз.


{% capture sample %}
```asm
; Подождем до получения следующего прерывания
EI
HLT ; zzz...

; Если мы здесь, то мы уже получили и обработали прерывание
; Снова включим получение прерываний 
EI
```
{% endcapture %}
{% include code-sample.html content=sample %}

## {{ jumps }} Переходы и вызовы 
{: #jumps }

Эти инструкции служат для изменения потока выполнения программы.
Используя эти инструкции, можно реализовать циклы, процедуры и функции, условные блоки (`if`/`else`) и другие похожие конструкции высокоуровневых языков программирования.

### Условные инструкции
{: #conditionals }

[{{up}} Вернуться к переходам и вызовам](#jumps)

У инструкций перехода есть три вида: [`JMP`](#jmp), [`CALL`](#call) и [`RET`](#ret).
Каждый из этих видов имеет 9 различных вариантов: один выполняет свое действие всегда, а остальные -- в зависимости от текущего состояния флагов процессора.
Все инструкции одного и того же вида имеют одинаковое поведение, если они выполняют переход,
поэтому их действие описано один раз для каждого вида.


| [`JMP`](#jmp) | [`CALL`](#call) | [`RET`](#ret) | переходит безусловно
| `JZ`  | `CZ`  | `RZ`  | переходит, если установлен флаг Z (результат равен 0)
| `JNZ` | `CNZ` | `RNZ` | переходит, если не установлен флаг Z (результат не равен 0)
| `JC`  | `CC`  | `RC`  | переходит, если установлен флаг CY (есть переполнение)
| `JNC` | `CNC` | `RNC` | переходит, если не установлен флаг CY (нет переполнения)
| `JPE` | `CPE` | `RPE` | переходит, если установлен флаг P (количество единиц в результате -- четное)
| `JPO` | `CPO` | `RPO` | переходит, если не установлен флаг P (количество единиц в результате -- нечетное)
| `JM`  | `CM`  | `RM`  | переходит, если установлен флаг S (результат меньше 0)
| `JP`  | `CP`  | `RP`  | переходит, если не установлен флаг S (результат больше или равен 0)


### JMP

[{{up}} Вернуться к переходам и вызовам](#jumps)

[Эта инструкция имеет условные варианты.](#conditionals)

Инструкция `JMP a16` принимает аргумент в виде адреса.
Если выполняется переход, то следующая инструкция, которую процессор начнет выполнять, будет находиться по этому адресу.

Эта инструкция может быть использована для того, чтобы:
- делать циклы
- реализовывать условные операторы
- пропускать куски памяти, которые не являются кодом

{% capture sample %}
```asm
; Перейти к адресу 0x1234
JMP 0x1234
; (или, если написать байты раздельно)
JMP 0x34 0x12
```

Выполним какое-то действие 10 раз:
```
; Сначала инициализируем счетчик: пусть в регистре A будет значение 10
MVI A, 10
; Метка начала цикла
loop:
    ; Выполним какое-то действие
    NOP ; ...
    NOP ; ...
    ; Сделали действие!
    ; Теперь вычтем единицу из счетчика
    DCR A
    ; Если счетчик еще не равен нулю, перейдем к началу цикла
    JNZ loop
; Если мы здесь, то мы не сделали переход в начало, значит цикл завершился
NOP ; ...
```


Получим значение из порта, и если оно имеет четное количество единиц, то выведем другое значение:
```
; Сначала считываем значение
IN 0xD0
; Проверяем его (устанавливаем флаги)
CPI 0x00
; Если оно не четное, то нужно пропустить следующий кусок кода
JPO not_even_parity
    ; Если мы здесь, то значение имеет четное количество единиц, и мы делаем вывод
    MVI A, 0x20
    OUT 0xD0
not_even_parity:
; Если мы здесь, значит мы либо выполнили переход и пропустили вывод, либо только что сделали вывод
NOP ; ...
```

Добавим строку внутри кода:
```
NOP ; ...
NOP ; ...
; Сейчас я хочу вывести какую-то строку на экран,
; но я хочу записать эту строку прямо здесь в памяти.
; Чтобы процессор не начал выполнять эту строку как код, мы должны пропустить ее.
JMP skip_string  ; перейдем на метку, которая после конца строки
string:  ; эта метка будет обозначать начало строки
  DB "HELLO WORLD!\0"  ; запишем строку в память
skip_string:  ; эта метка указывает на инструкции после конца строки
LXI BC, string  ; передадим адрес строки в регистр BC
CALL 0x0043     ; вызовем функцию вывода строки
```
{% endcapture %}
{% include code-sample.html content=sample %}

### CALL

[{{up}} Вернуться к переходам и вызовам](#jumps)

[Эта инструкция имеет условные варианты.](#conditionals)

Инструкция `CALL a16`, как и инструкция `JMP a16`, принимает в качестве аргумента адрес, к которому нужно перейти.
Однако при вызове `CALL`, помимо перехода, дополнительно значение регистра PC записывается в стек.
Это нужно, чтобы будущая инструкция [`RET`](#ret) могла вернуться в этот код.

Эта инструкция используется для того, чтобы вызывать подпрограммы -- куски кода, которые нужно использовать несколько раз.
Когда выполняется `CALL`, процессор запоминает на стек, как вернуться к основной программе, и затем начинает выполнять подпрограмму.
Когда подпрограмма завершается, она использует инструкцию `RET`, и процессор достает этот запомненный адрес из стека и переходит к нему, возвращаясь в основную программу.

Инструкция `CALL` только сохраняет адрес возврата в стеке -- она не изменяет регистры или флаги. Это означает, что текущие значения регистров доступны подпрограмме, и являются основным способом передачи данных в подпрограмму.

{% capture sample %}
```asm
; Подпрограмма, которая умножает значение в регистре A на 10
times_10:
    ; мы будем использовать регистр B как временное хранилище
    ; запишем его текущее значение на стек
    PUSH BC
    ; A = x
    ADD A    ; A = x + x = 2*x
    MOV B,A  ; B = A = 2*x
    ADD A    ; A = 2*x + 2*x = 4*x
    ADD A    ; A = 4*x + 4*x = 8*x
    ADD B    ; A = 8*x + 2*x = 10*x
    ; вернем значение из стека в регистр B
    POP BC
    ; возвращаемся в основную программу
    RET

; Установим значение регистра A
MVI A, 3
; Вызовем подпрограмму
CALL times_10
; Теперь значение регистра A будет равно 30
```
{% endcapture %}
{% include code-sample.html content=sample %}

### RET

[{{up}} Вернуться к переходам и вызовам](#jumps)

[Эта инструкция имеет условные варианты.](#conditionals)

Инструкция `RET` считывает значение из стека и переходит к адресу, записанному в этом значении.

Используя эту инструкцию, можно создавать подпрограммы --
куски кода, которые можно использовать несколько раз из разных мест основной программы.

Если подпрограмма использует [инструкции управления стеком](#push-pop), то следует быть аккуратным при написании кода,
чтобы к моменту вызова `RET` стек был на том же уровне, что и в начале подпрограммы.
Это из-за того, что при вызове `RET`, процессор достает значение из стека и переходит к адресу, записанному в этом значении,
и если программа выполнила `PUSH`, который не был взят обратно с `POP`,
то при попытке вернуться в основную программу, процессор вместо этого не вернется к ожидаемому адресу.

{% capture sample %}
```asm
; Подпрограмма, которая умножает значение в регистре A на 10
times_10:
    ; мы будем использовать регистр B как временное хранилище
    ; запишем его текущее значение на стек
    PUSH BC
    ; A = x
    ADD A    ; A = x + x = 2*x
    MOV B,A  ; B = A = 2*x
    ADD A    ; A = 2*x + 2*x = 4*x
    ADD A    ; A = 4*x + 4*x = 8*x
    ADD B    ; A = 8*x + 2*x = 10*x
    ; вернем значение из стека в регистр B
    POP BC
    ; возвращаемся в основную программу
    RET

; Установим значение регистра A
MVI A, 3
; Вызовем подпрограмму
CALL times_10
; Теперь значение регистра A будет равно 30
```

Пример проблемы при вызове `RET` с использованием стека:

```asm
; Подпрограмма, которая делает что-то полезное
subprogram:
  NOP  ; ...
  NOP  ; ...
  ; ... Во время работы подпрограммы мы положили значение на стек
  MVI H, 0x40
  MVI L, 0x00
  PUSH HL
  NOP  ; ...
  NOP  ; ...
  ; !!! Мы забыли сделать POP !!!
  RET  ; Этот RET считает значение от PUSH и перейдет к адресу 0x4000 !!


; Если попробовать использовать эту подпрограмму в основной программе...
NOP   ; ...
NOP   ; ...
CALL subprogram
NOP   ; <-- Этот код не будет выполнен -- мы не вернемся сюда
```
{% endcapture %}
{% include code-sample.html content=sample %}


### RST

[{{up}} Вернуться к переходам и вызовам](#jumps)

Инструкции `RST 0`, `RST 1` ... `RST 7` выполняют то же самое, что [`CALL`](#call), к адресу `0x0000 + n*8`, где `n` от 0 до 7.
Это означает, что при вызове `RST 0`, процессор перейдет к адресу `0x0000`,
при вызове `RST 1` процессор перейдет к адресу `0x0008`,
при вызове `RST 2` процессор перейдет к адресу `0x0010` и т.д.

Эти инструкции полезны больше всего для работы с внешними прерываниями.
Когда происходит прерывание, процессор считывает и выполняет одну инструкцию с шины данных,
прежде чем продолжить работать как обычно.
Каждая из инструкций `RST` занимает один байт, поэтому
если в этот момент на шине данных выставить один из восьми опкодов `RST`,
то процессор запомнит свое последнее положение в коде на стек.
и выполнит код для обработки прерывания.
Процедура прерывания затем может использовать [`RET`](#ret), чтобы вернуться к основному коду и продолжить работу как обычно.

Эти опкоды также являются обычными инструкциями, поэтому можно использовать их в своем коде.
Например, если вызвать инструкцию `RST 0`, то процессор перейдет к адресу `0x0000`,
как будто он был толькол что перезагружен с помощью линии `RESET`.

{% capture sample %}
```asm
; Бесконечно принимаем значение из порта
; Если это значение стало равно 0, перезагружаем процессор
loop:
  IN 0x80   ; считываем значение
  CPI 0x00  ; сравниваем с 0
  JNZ loop  ; если не равно, продолжаем цикл
; теперь значение равно 0
RST 0     ; перезагружаем процессор
```
{% endcapture %}
{% include code-sample.html content=sample %}

## {{mov8}} Загрузка, сохранение и перемещение, 8-бит
{: #mov8 }

Эти инструкции используются для перемещения информации, один байт за раз.

### MOV

[{{up}} Вернуться к инструкциям перемещения, 8-бит](#mov8)

Эта инструкция копирует значение из источника в назначение.
Она является одной из самых часто используемых во всем наборе инструкций.

Она принимает два аргумента: назначение и источник.
Эти два аргумента являются частью одного байта, и поэтому одна эта инструкция занимает почти четверть всего пространства инструкций.

Первый аргумент -- это назначение, а второй аргумент -- это источник.
Можно читать это как операцию присваивания: `MOV X,Y` значит `X = Y`.

Аргументы -- это один из следующих символов: `A`, `B`, `C`, `D`, `E`, `H`, `L`, `M`.
Первые семь из этих -- это названия регистров процессора, и операции между ними осуществляются полностью внутри процессора.
Аргумент `M` -- особенный: он обозначает ячейку памяти, адрес которой записан в паре регистров `HL`.

Операции вида `MOV X,X` копируют значение из какого-то регистра в сам этот регистр, тем самым не меняя его значение.
Таким образом, они являются альтернативой [`NOP`](#nop).
В определенных задачах, когда важно, сколько времени занимает выполнение инструкций, операции вида `MOV X,X` действительно использовались как слегка более длительный `NOP`.

Среди набора инструкций отсутствует инструкция `MOV M,M` -- ее место занимает инструкция [`HLT`](#hlt).

{% capture sample %}
```asm
; Скопировать значение из регистра B в регистр A
MOV A,B

; Скопировать значение из памяти по адресу `0x1234` в регистр C
LXI H, 0x1234
MOV C, M

; Скопировать значение из памяти `0x1234` в `0x5678`, через регистр D
LXI H, 0x1234
MOV D, M  ; теперь D содержит значение из памяти 0x1234
LXI H, 0x5678
MOV M, D  ; теперь память 0x5678 содержит значение в D, которое было скопировано из памяти 0x1234
```
{% endcapture %}
{% include code-sample.html content=sample %}

### MVI

[{{up}} Вернуться к инструкциям перемещения, 8-бит](#mov8)

Инструкция `MVI` загружает в регистр значение, которое передается как аргумент.

Регистр задается таким же образом, как и в операции [`MOV`](#mov) -- один из `A`, `B`, `C`, `D`, `E`, `H`, `L`, `M`.

  
{% capture sample %}
```asm
; Загрузить значение 0x12 в регистр A
MVI A, 0x12

; Загрузить значение 0x34 в память по адресу 0xABCD
LXI H, 0xABCD
MVI M, 0x34
```
{% endcapture %}
{% include code-sample.html content=sample %}

### LDAX/STAX
{: #ldax-stax }

[{{up}} Вернуться к инструкциям перемещения, 8-бит](#mov8)

Эта инструкция перемещает значение между регистром A и памятью по адресу в паре регистров.

Принимается аргумент -- один символ, `B` или `D` -- который обозначает, что нужно использовать адрес в регистрах `BC` или `DE`, соответственно.
Инструкция `LDAX` считывает значение из памяти в регистр A, а `STAX` -- наоборот, из регистра в память.

{% capture sample %}
```asm
; Считать значение из памяти по адресу 0x1234 в регистр A
LXI B, 0x1234
LDAX B

; Переместить значение из памяти по адресу 0x1234 в память по адресу 0x5678 через регистр A
LXI B, 0x1234
LXI D, 0x5678
LDAX B
STAX D
```
{% endcapture %}
{% include code-sample.html content=sample %}

### LDA/STA
{: #lda-sta }

[{{up}} Вернуться к инструкциям перемещения, 8-бит](#mov8)

Эта инструкция делает то же самое, что и [`LDAX/STAX`](#ldax-stax) -- загружает или сохраняет значение между памятью и регистром A.
В отличии от `LDAX/STAX`, эта инструкция принимает аргумент -- адрес, относительно которого следует произвести операцию.

    
{% capture sample %}
```asm
; Считать значение из памяти по адресу 0x1234 в регистр A
LDA 0x1234

; Переместить значение из памяти по адресу 0x1234 в память по адресу 0x5678 через регистр A
LDA 0x1234
STA 0x5678
```
{% endcapture %}
{% include code-sample.html content=sample %}


## {{mov16}} Загрузка, сохранение и перемещение, 16-бит
{: #mov16 }

Эти инструкции используются для перемещения пар байтов.

### LXI

[{{up}} Вернуться к инструкциям перемещения, 16-бит](#mov16)

Эта инструкция загружает значение аргумента в пару регистров.

Принимает два аргумента: название пары регистров (`B` для `BC`, `D` для `DE`, `H` для `HL` или `SP` для регистра-указателя на стек), и 16-битное значение.
Загружает значение в указанную пару регистров.

{% capture sample %}
```asm
; Загрузить значение 0x1234 в пару регистров BC
LXI B, 0x1234

; Инициализировать стек по адресу 0xff00
LXI SP, 0xff00
```
{% endcapture %}
{% include code-sample.html content=sample %}


### LHLD/SHLD
{: #lhld-shld }

[{{up}} Вернуться к инструкциям перемещения, 16-бит](#mov16)

Эти две инструкции используются для перемещения значения между парой регистров `HL` и памятью.

Обе инструкции принимают аргумент -- адрес `a16`.
Инструкция `LHLD` считывает значение по адресу `a16` в регистр `L`, а значение по адресу `a16 + 1` в регистр `H`.
Инструкция `SHLD`, наоборот, записывает значение `L` в `a16`, а `H` -- в `a16 + 1`.

{% capture sample %}
```asm

; Загрузить значение из адреса 0x4000 в HL
LHLD 0x4000

; Сохранить значение из HL в адрес 0x4000
SHLD 0x4000

; Сохранить значение 0xBEEF в адрес 0x1234 через HL
LXI H, 0xBEEF
SHLD 0x1234
```
{% endcapture %}
{% include code-sample.html content=sample %}

### PUSH/POP
{: #push-pop }

[{{up}} Вернуться к инструкциям перемещения, 16-бит](#mov16)

Эти две инструкции используются для того, чтобы манипулировать стеком.

Стек -- это область памяти, которую можно использовать для хранения временных значений.
Например, там хранятся адреса возврата для подпрограмм, вызываемых с помощью [`CALL`](#call).

Обе инструкции принимают аргумент -- один из `B`, `D`, `H` или `PSW`. Это -- название пары регистров, которые будут записаны в стек или извлечены из него.

Поскольку адреса для возвращения из подпрограммы также находятся в стеке, следует быть осторожным при использовании стека в своих программах.
К тому моменту, как вызывается [`RET`](#ret), следует убедиться, что все операции `PUSH` имеют соответствующие им операции `POP` (можно представлять `PUSH` и `POP` как скобки вокруг блоков кода -- тогда это правило значит, что последовательность скобок должна быть правильной).
Это нужно потому, что, если на верху стека лежит что-то кроме адреса возврата, то при выполнении `RET` процессор перейдет не обратно в основную программу, а в неизвестное место в памяти.

Инструкция `PUSH` делает следующее:

1. Записывает старшие 8 битов значения пары регистров в адрес `SP - 1`.
2. Записывает младшие 8 битов значения пары регистров в адрес `SP - 2`.
3. Уменьшает значение `SP` на 2.

Инструкция `POP` делает следующее:

1. Извлекает младшие 8 битов значения пары регистров из адреса `SP`.
2. Извлекает старшие 8 битов значения пары регистров из адреса `SP + 1`.
3. Увеличивает значение `SP` на 2.

Аргумент `B` значит, что старшим байтом считается регистр `B`, а младшим -- `C`.
Аргумент `D` значит, что старшим байтом считается регистр `D`, а младшим -- `E`.
Аргумент `H` значит, что старшим байтом считается регистр `H`, а младшим -- `L`.

Аргумент `PSW` (*Program Status Word*) особенный -- для него старшим байтом считается значение регистра `A`, а младшим -- особый байт, содержащий все флаги процессора:

Бит      | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
---------|---|---|---|---|---|---|---|---|
Значение |`S`|`Z`|всегда 0|`AC`|всегда 0|`P`|всегда 1|`CY`|

При `PUSH PSW` биты 5, 3 и 1 младшего байта, который находится на стеке, имеют значения 0, 0 и 1 соответственно.
При `POP PSW` биты 5, 3 и 1 игнорируются.

{% capture sample %}
```asm
; Записать в стек значение всех регистров
PUSH B
PUSH D
PUSH H
PUSH PSW

; Выполнить что-то...
NOP
NOP
; ...сохраняем результаты работы в память...
NOP

; Теперь возвращаем процессор в исходное состояние всех регистров
; (результаты работы были записаны в память)

POP PSW  ; инструкции POP идут в обратном порядке от PUSH
POP H
POP D
POP B
```
{% endcapture %}
{% include code-sample.html content=sample %}

### SPHL

[{{up}} Вернуться к инструкциям перемещения, 16-бит](#mov16)


Эта инструкция загружает в регистр `SP` значение из пары регистров `H` и `L`.
Значение в `HL` не изменяется.

{% capture sample %}
```asm
; Инициализировать стек по адресу `0xfff0`
LXI H, 0xff
LXI L, 0xf0
SPHL  ; теперь SP = HL = 0xfff0
```
{% endcapture %}
{% include code-sample.html content=sample %}

### XCHG

[{{up}} Вернуться к инструкциям перемещения, 16-бит](#mov16)


Эта инструкция меняет местами значения в паре регистров `DE` и `HL`.

{% capture sample %}
```asm
MVI D, 0xDE
MVI E, 0xAD
MVI H, 0xBE
MVI L, 0xEF
; Теперь DE = 0xDEAD, HL = 0xBEEF
XCHG
; Теперь DE = 0xBEEF, HL = 0xDEAD
```
{% endcapture %}
{% include code-sample.html content=sample %}

### XTHL

[{{up}} Вернуться к инструкциям перемещения, 16-бит](#mov16)


Эта инструкция меняет местами значение в паре регистров `HL` и значение на верхушке стека.

Более точно, сначала меняется местами значение регистра `L` и ячейки памяти по адресу `SP`,
а затем меняется местами значение регистра `H` и ячейки памяти по адресу `SP+1`.

{% capture sample %}
```asm
LXI B, 0xABCD
PUSH B
LXI H, 0x1234
; Теперь на верхушке стека лежит значение 0xABCD, а HL=0x1234
XTHL
; Теперь на верхушке стека лежит значение 0x1234, а HL=0xABCD
```
{% endcapture %}
{% include code-sample.html content=sample %}

## {{alu8}} Арифметические и логические операции, 8-бит
{: #alu8 }

Эти инструкции выполняют преобразования над 8-битными значениями.
Каждая из этих инструкций принимает значение из регистра `A`, преобразует его и записывает в регистр `A`.

### Информация про флаги
{: #alu8-flags }

[{{up}} Вернуться к арифметико-логическим инструкциям, 8-бит](#alu8)

У процессора есть 5 флагов, которые обозначают результаты выполнения арифметических и логических операций.
Эти флаги называются `S`, `Z`, `AC`, `P`, `CY`.

Для флагов, слово "установить" значит "сделать равным 1", а "сбросить" -- "сделать равным 0".

- `Z` (*Zero*) -- устанавливается, если результатом операции является 0.
- `S` (*Sign*) -- устанавливается, если результат операции отрицательный (используя [дополнительный код](https://ru.wikipedia.org/wiki/%D0%94%D0%BE%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%B4), то есть если старший бит результата равен 1).
- `P` (*Parity*) -- устанавливается, если двоичное представление результата операции имеет нечетное число единиц.
- `CY` (*Carry*) -- устанавливается, если при выполнении операции произошло переполнение.
- `AC` (*Auxiliary Carry*) -- устанавливается, если при выполнении операции произошло переполнение из бита 3 (используется только для инструкции [`DAA`](#daa)).

Флаг `P` всегда обозначает четность результата.
Флаг `Z` всегда устанавливается, если результат операции равен 0.
Флаг `S` всегда обозначает значение старшего бита.
Значение флагов `CY` и `AC` определяется в зависимости от инструкции.

### Инструкции с immediate-значением
{: #alu8-immediate }

[{{up}} Вернуться к арифметико-логическим инструкциям, 8-бит](#alu8)

Некоторые инструкции, которые принимают как аргумент название регистра со значением,
имеют альтернативный вариант.
В этом альтернативном варианте они принимают как аргумент само это значение.
Значение, написанное непосредственно в коде, называется `immediate`.

Поведение этих инструкций идентично поведению обычных вариантов, в том числе работа с флагами.
Для информации по этим вариантам смотри документацию обычного варианта инструкции.

Обычная инструкция  | Immediate-вариант
------------------- | -----------------
 [`ADD`](#add)      | `ADI`
 [`ADC`](#adc)      | `ACI`
 [`SUB`](#sub)      | `SUI`
 [`SBB`](#sbb)      | `SBI`
 [`CMP`](#cmp)      | `CUI`
 [`ANA`](#and)      | `ANI`
 [`XRA`](#xra)      | `XRI`
 [`ORA`](#ora)      | `ORI`
 [`CMP`](#cmp)      | `CPI`

{% capture sample %}
```asm
; Пример инструкции ADD
MVI A, 0x01
MVI B, 0x02
ADD B
; Теперь A = 0x03

; Пример замены этой инструкции на immediate-вариант
MVI A, 0x01
ADI 0x02
; Теперь A = 0x03
```
{% endcapture %}
{% include code-sample.html content=sample %}

### ADD

[{{up}} Вернуться к арифметико-логическим инструкциям, 8-бит](#alu8)

[Эта инструкция имеет immediate-вариант.](#alu8-immediate)

Эта инструкция добавляет к значению в аккумуляторе значение из аргумента.

Если результат оказывается больше 255, то происходит переполнение.
Из итогового результата вычитается 256 (то есть, если результат был 257, то в `A` будет записано 1, и т. д.),
а флаг `CY` будет установлен.

Если при сложении двух значений в столбик получается перенос в бит 4 из бита 3, то устанавливается флаг `AC`.
Пример:

|Номер бита | 7 | 6 | 5 | 4        | 3 | 2 | 1 | 0 |
|-----------|---|---|---|----------|---|---|---|---|
| `0x2E`    | 0 | 0 | 1 | 0        | 1 | 1 | 1 | 0 |
| `+ 0x74`  | 0 | 1 | 1 | 1        | 0 | 1 | 0 | 0 |
| `= 0xA2`  | 1         | 0 | 1 | 0        | 0 | 0 | 1 | 0 |
|           | {{down}}  |   |   | {{down}} |   |   |   |   |
|           | `CY=0`    |   |   | `AC=1`   |   |   |   |   |

[Флаги `Z`, `S` и `P` обновляются как обычно.](#alu8-flags)

### ADC

[{{up}} Вернуться к арифметико-логическим инструкциям, 8-бит](#alu8)

[Эта инструкция имеет immediate-вариант.](#alu8-immediate)

Эта инструкция выполняет то же самое, что и [`ADD`](#add),
только к результату ещё добавляется значение флага `CY`.
Эта инструкция полезна, когда производится сложение над числом, занимающим несколько байтов.

### SUB

[{{up}} Вернуться к арифметико-логическим инструкциям, 8-бит](#alu8)

[Эта инструкция имеет immediate-вариант.](#alu8-immediate)

Эта инструкция вычитает из значения в аккумуляторе значение аргумента, согласно правилам [дополнительного кода](https://ru.wikipedia.org/wiki/%D0%94%D0%BE%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%B4)

Если из старшего бита *нет* переноса -- то есть если было заимствование -- то флаг `CY` *устанавливается*, иначе сбрасывается.
Это противоположное поведение от операции сложения, где `CY` сбрасывается при отсутствии переполнения.

[Флаги `Z`, `S` и `P` обновляются как обычно.](#alu8-flags)

### SBB

[{{up}} Вернуться к арифметико-логическим инструкциям, 8-бит](#alu8)

[Эта инструкция имеет immediate-вариант.](#alu8-immediate)

Сначала, значение флага `CY` внутренне добавляется к значению аргумента.
Затем результат этого вычитается из аккумулятора, как с [`SUB`](#sub).

### ANA

[{{up}} Вернуться к арифметико-логическим инструкциям, 8-бит](#alu8)

[Эта инструкция имеет immediate-вариант.](#alu8-immediate)

Выполняет побитовое И между значением аккумулятора и значением аргумента.
Для каждого из 8 битов, если значение бита в аккумуляторе и значение бита в аргументе равно 1, то в ответе бит устанавливается в 1, иначе 0.

Флаг `CY` сбрасывается.
[Флаги `Z`, `S` и `P` обновляются как обычно.](#alu8-flags)


### XRA

[{{up}} Вернуться к арифметико-логическим инструкциям, 8-бит](#alu8)

[Эта инструкция имеет immediate-вариант.](#alu8-immediate)

Выполняет побитовое исключительное-ИЛИ между значением аккумулятора и значением аргумента.
Для каждого из 8 битов, если значение бита в аккумуляторе и значение бита в аргументе различается, то в ответе бит устанавливается в 1, иначе 0.

Флаги `CY` и `AC` сбрасывается.
[Флаги `Z`, `S` и `P` обновляются как обычно.](#alu8-flags)

### ORA

[{{up}} Вернуться к арифметико-логическим инструкциям, 8-бит](#alu8)

[Эта инструкция имеет immediate-вариант.](#alu8-immediate)

Выполняет побитовое ИЛИ между значением аккумулятора и значением аргумента.
Для каждого из 8 битов, если либо значение бита в аккумуляторе, либо значение бита в аргументе равно 1, то в ответе бит устанавливается в 1, иначе 0.

Флаги `CY` и `AC` сбрасывается.
[Флаги `Z`, `S` и `P` обновляются как обычно.](#alu8-flags)


### CMP

[{{up}} Вернуться к арифметико-логическим инструкциям, 8-бит](#alu8)

[Эта инструкция имеет immediate-вариант.](#alu8-immediate)

Эта инструкция выполняет сравнение значения аккумулятора с значением аргумента.

Внутренне, из значения регистра `A` [вычитается](#sub) значение аргумента,
результат игнорируется (оба регистра остаются неизменными),
а флаги устанавливаются в соответствии с результатом вычитания.

В частности, `Z` будет установлен, если два значения равны, и сброшен, если они не равны.
Поскольку выполняется вычитание, флаг `CY` будет установлен, если значение аргумента больше значения аккумулятора, и сброшен иначе.

[Флаги `Z`, `S` и `P` обновляются как обычно](#alu8-flags) (относительно результата внутреннего вычитания).


### INR/DCR
{: #inr-dcr }

[{{up}} Вернуться к арифметико-логическим инструкциям, 8-бит](#alu8)

Эти две инструкции изменяют значение указываемого регистра на 1.
Операция `INR X` эквивалентна [`ADI X, 1`](#add), а `DCR X` эквивалентна [`SUI X, 1`](#sub).
Поэтому, она также изменяет флаги `Z`, `S`, `P` и `AC` таким же образом, как и соответствующие инструкции сложения и вычитания.

### RLC/RRC/RAL/RAR
{: #rlc-rrc-ral-rar }

[{{up}} Вернуться к арифметико-логическим инструкциям, 8-бит](#alu8)

Эти четыре инструкции служат для побитового сдвига аккумулятора.
`RLC` вращает регистр влево {{left}}, `RRC` -- вправо {{right}}, а `RAL` и `RAR` вращают регистр через флаг переноса `CY`.
**Важно заметить**, это противоположно интуиции -- инструкции с буквой `C` в названии **не используют флаг `CY`** для осуществления переноса, а `RLC` и `RRC`, наоборот, используют.

В микроконтроллерах, современных Intel 8080, по умолчанию осуществлялся `N+1`-перенос,
и по умолчанию сдвиги производились через бит переноса.
Можно запомнить операции `RLC` и `RRC` как `Rotate Left/Right and Copy`.
Более детальное обсуждение можно увидеть в [вопросе на Retrocomputing Stack Exchange](https://retrocomputing.stackexchange.com/q/24782/24948).

Побитовый сдвиг -- это операция, при которой биты регистра перемещаются между позициями:

| Состояние регистра | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
|--------------------|---|---|---|---|---|---|---|---|
| Начальное значение | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 |
| После сдвига вправо {{right}} | 0 | 1 | 1 | 1 | 1 | 0 | 0 | 0 |
| После сдвига влево {{left}}   | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 1 |

В этой таблице приведен пример сдвига, при котором тот бит, который оказался выдвинут из байта, оказывается на противоположном конце байта --
например, при сдвиге вправо {{right}} бит 0 перешел в бит 7, 
а при сдвиге влево {{left}} бит 7 перешел в бит 0.
Так работают операции `RLC` и `RRC`.
При выполнении этих операций бит, который оказался выдвинут, также записывается в флаг переноса `CY`.

При операции `RAL`/`RAR` также осуществляется сдвиг, но на этот раз по 9-битному значению, составленному из 8-битного аккумулятора и бита переноса `CY`.
При `RAL` сдвиг происходит влево {{left}}, и флаг `CY` дописывается слева {{left}} от аккумулятора.

| Состояние регистров | `CY` | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
|---------------------|------|---|---|---|---|---|---|---|---|
| До `RAL`            |  0   | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 |
| После `RAL`         |  1   | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 |
| После двух `RAL`    |  1   | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 1 |
| После трех `RAL`    |  1   | 1 | 0 | 0 | 0 | 0 | 0 | 1 | 1 |
| После четырех `RAL` |  1   | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 |
| После пяти `RAL`    |  0   | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 |
| После шести `RAL`   |  0   | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 |

При `RAR` сдвиг происходит вправо {{right}}, и флаг `CY` дописывается справа {{right}} от аккумулятора.

| Состояние регистров | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 | `CY` |
|---------------------|---|---|---|---|---|---|---|---|------|
| До `RAR`            | 1 | 1 | 0 | 0 | 0 | 0 | 1 | 1 | 0    |
| После `RAR`         | 0 | 1 | 1 | 0 | 0 | 0 | 0 | 1 | 1    |
| После двух `RAR`    | 1 | 0 | 1 | 1 | 0 | 0 | 0 | 0 | 1    |
| После трех `RAR`    | 1 | 1 | 0 | 1 | 1 | 0 | 0 | 0 | 0    |
| После четырех `RAR` | 0 | 1 | 1 | 0 | 1 | 1 | 0 | 0 | 0    |
| После пяти `RAR`    | 0 | 0 | 1 | 1 | 0 | 1 | 1 | 0 | 0    |
| После шести `RAR`   | 0 | 0 | 0 | 1 | 1 | 0 | 1 | 1 | 0    |

### DAA

[{{up}} Вернуться к арифметико-логическим инструкциям, 8-бит](#alu8)

Эта инструкция изменяет значение в аккумуляторе, используя значения в флагах `CY` и `AC`, чтобы преобразовать результат операции [`ADD`](#add) или [`SUB`](#sub) в  значение в двоично-десятичном формате.

Одно 8-битное значение может представлять две десятичных цифры, если старшие и младшие 4 бита каждый не превышают 9.
Между несколькими байтами, содержащими так закодированные значения, можно выполнять арифметику, используя обычные 8-битные арифметические операции -- нужно лишь проверять, что после каждой операции сохраняется свойство, что каждые из 4-битных значений не превышают 9.
Операция `DAA` (`Decimal Adjust Accumulator`) осуществляет эту проверку и изменение по следующим правилам:

1. Если младшие 4 бита имеют значение больше 9, или если флаг `AC` установлен, то значение аккумулятора увеличивается на 6, иначе увеличение не происходит. Если произошел перенос из младших 4 битов, устанавливается флаг `AC`.
2. Если после шага 1 старшие 4 бита аккумулятора имеют значение больше 9, или если установлен флаг `CY`, то значение старших 4 битов увеличивается на 6, иначе увеличение не происходит. Если произошел перенос из старших 4 битов, устанавливается флаг `CY`.

[Флаги `Z`, `S` и `P` обновляются как обычно.](#alu8-flags)

Псевдокод для операции `DAA` (списано из [кода эмулятора Intel 8080](https://github.com/duongvuhong/intel8080/blob/master/intel_8080.c#L402)):

```
procedure DAA is
  NCY := RegF.CY
  correction := 0x00
  LSB := RegA & 0x0F
  MSB := RegA >> 4

  if RegF.AC or LSB > 9 then
    correction := 0x06
  end if

  if RegF.CY or MSB > 9 or (MSB >= 9 and LSB >= 9) then
    correction := (correction | 0x60)
    NCY := 1
  end if

  call ADI(correction)
  RegF.CY := NCY
end procedure
```

### STC/CMC
{: #stc-cmc }

[{{up}} Вернуться к арифметико-логическим инструкциям, 8-бит](#alu8)

Эти две инструкции используются для управления флагом `CY`.
Инструкция `STC` устанавливает флаг `CY` в состояние `1`, а инструкция `CMC` изменяет его значение на противоположное.

{% assign neq = "≠" %}

{% capture sample %}
```asm
STC
; Теперь `CY=1`
JNC 0x4000  ; переход не будет осуществлен, потому что `CY {{neq}} 0`

CMC
; Теперь `CY=0`
JNC 0x4000  ; переход будет осуществлен, потому что `CY = 0`
```
{% endcapture %}
{% include code-sample.html content=sample %}

## {{alu16}} Арифметико-логические инструкции, 16-бит
{: #alu16 }

Эти инструкции используются для выполнения арифметических операций над 16-битными значениями.

### INX/DCX
{: #inx-dcx }

[{{up}} Вернуться к арифметико-логическим инструкциям, 16-бит](#alu16)

Эти две инструкции позволяют инкрементировать или декрементировать (то есть, изменять на единицу в обе стороны)
значение пары регистров `BC` (через аргумент `B`), `DE` (`D`), `HL` (`H`) или регистра -- указателя на верхушку стека `SP`.

Эти операции **не изменяют значение флагов** и тихо переполняются через 16-битные значения.
Например, если в `H` есть значение `0x7f`, а в `L` есть значение `0xff`, то после выполнения `INX H`, в `H` будет значение `0x80`, а в `L` будет значение `0x00`.
Аналогично, если сначала `B` равен `0xff` и `C` равен `0xff`, то после выполнения `INX B`, в `B` будет `0x00`, а в `C` будет `0x00`.

Эти инструкции больше всего полезны для манипуляции адресами памяти.
Например, комбинированный регистр `HL` используется как указатель в память для записи или чтения,
и используя операции `INX` и `DCX`, можно перемещать этот указатель между близкими адресами.

{% capture sample %}
```asm
; В бесконечном цикле, двигать указатель вперед по памяти,
; и для каждой ячейки увеличить их значение на 5.
; (Эта программа перезапишет всю память, в том числе
; свой собственный код, поэтому цикл не будет выполняться бесконечно.)

LXI H, 0x0000 ; перейти к началу памяти
loop:     ; метка на начало цикла
MOV A, M  ; загрузить значение из памяти
ADI 5     ; прибавить 5 к аккумулятору
MOV M, A  ; записать значение в память
INX H     ; перейти к следующей ячейке памяти
JMP loop  ; перейти к началу цикла
```
{% endcapture %}
{% include code-sample.html content=sample %}

### DAD

[{{up}} Вернуться к арифметико-логическим инструкциям, 16-бит](#alu16)

Эта инструкция выполняет сложение между 16-битными значениями.
К значению в регистрах `HL` добавляется значение из одного из регистров `BC`, `DE`, `HL`, `SP`.
Если результат оказывается больше максимального 16-битного значения, то устанавливается флаг `CY`.

  
{% capture sample %}
```asm
LXI H, 0x7f00
LXI B, 0x0100
; Теперь HL=0x7f00, BC=0x0123
DAD B
; Теперь HL=0x8023, CY=0

LXI H, 0xf000
LXI D, 0x1100
; Теперь HL=0xf000, DE=0x1100
DAD D
; Теперь HL=0x0100, CY=1
```
{% endcapture %}
{% include code-sample.html content=sample %}


# {{danger}} Неопределенные инструкции
{: #undefined-instructions }

[{{up}} Вернуться к списку инструкций](#opcodes)

Некоторые из опкодов являются незадокументированными в спецификации к процессору Intel 8080.

В стандартном Intel 8080 эти опкоды вызывают такое же поведение, как и какие-то другие. 
В [списке инструкций](#opcodes) написано, какую инструкцию копирует эта.

Однако в коде использовать эти инструкции не следует.
Другие процессоры, например Zilog Z80, используют эти опкоды для каких-то других инструкций,
поэтому если попробовать выполнить инструкцию с этим опкодом, процессор может выполнить неожиданное действие.
Учитывая то что с помощью этих опкодов нельзя сделать ничего нового, рекомендуется просто расценивать их как запрещенные к использованию.