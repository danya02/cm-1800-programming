---
layout: post
title: "Список и таблица опкодов"
permalink: /opcodes/
---

{% capture tldr %}
В этом посте:

- Список опкодов в порядке их бинарного кода
- Таблица опкодов
- Объяснение по категориям инструкций
{% endcapture %}
{% include info-callout.html content=tldr %}

# Аттрибуция

При составлении этой страницы использованы материалы:

- [Таблица опкодов на сайте Pastaraiser](https://www.pastraiser.com/cpu/i8080/i8080_opcodes.html), из которой я узнал про существование всех инструкций и использовал ее постоянно при написании программ
- [Intel 8080 Programmer's Manual](https://drakeor.com/uploads/8080-Programmers-Manual.pdf) -- официальное руководство к программированию для процессора I8080


# Категории инструкций

Все инструкции можно разделить на 6 категорий:
{% assign control="&#x1f527;" %}{% comment %}U+1F527 WRENCH{% endcomment %}
{% assign jumps="&#x2935;" %}{% comment %}U+2935 RIGHT ARROW CURVING DOWN{% endcomment %}
{% assign mov8="&#x1f4e9;" %}{% comment %}U+1F4E9 ENVELOPE WITH ARROW{% endcomment %}
{% assign mov16="&#x1f4e5;" %}{% comment %}U+1F4E5 INBOX TRAY{% endcomment %}
{% assign alu8="&#x1f9ee;" %}{% comment %}U+1F9EE ABACUS{% endcomment %}
{% assign alu16="&#x1f4d0;" %}{% comment %}U+1F4D0 TRIANGULAR RULER{% endcomment %}
{% assign danger="&#x1f92c;" %}{% comment %}U+1F92C FACE WITH SYMBOLS ON MOUTH{% endcomment %}
{% assign noflags="&empty;" %}


- {{ control }} Управление процессором
- {{ jumps }} Переходы и вызовы
- {{ mov8 }} Загрузка, сохранение и перемещение, 8-бит
- {{ mov16 }} Загрузка, сохранение и перемещение, 16-бит
- {{ alu8 }} Арифметические и логические операции, 8-бит
- {{ alu16 }} Арифметические и логические операции, 16-бит

Некоторые инструкции не следует использовать. Они помечены: {{ danger }}.

# Список опкодов

<style markdown="0">
#opcodes > tbody > tr > td:first-child + td {
  font-size: xxx-large; /* make emoji column big */
}
</style>


Опкод (hex) | Категория | Мнемоника | Краткое описание  | Затронутые флаги | Ссылка на описание |
--------------------------|----------|------------|-------------------|------------------|-------------------|
<span markdown="0" id="00">00</span> | {{control}} | NOP | Ничего не делает | {{noflags}} | [NOP](#nop) 
<span markdown="0" id="01">01</span> {2} {3} | {{ mov16 }} | LXI B, d16 | B <- {2}, C <- {3} | {{noflags}} | [LXI](#lxi)
<span markdown="0" id="02">02</span> | {{mov8}} | STAX B | (BC) <- A | {{noflags}} | [LDAX/STAX](#ldax-stax)
<span markdown="0" id="03">03</span> | {{ alu16 }} | INX B  | BC <- BC + 1 | {{noflags}} | [INX/DCX](#inx-dcx)
<span markdown="0" id="04">04</span> | {{alu8}} | INR B | B <- B + 1 | Z, S, P, AC | [INR/DCR](#inr-dcr)
<span markdown="0" id="05">05</span> | {{alu8}} | DCR B | B <- B - 1 | Z, S, P, AC | [INR/DCR](#inr-dcr)
<span markdown="0" id="06">06</span> {2} | {{mov8}} | MVI B, d8 | B <- {2} | {{noflags}} | [MVI](#mvi)
<span markdown="0" id="07">07</span> | {{alu8}} | RLC | A <- A << 1 (CY = пред. бит 7; бит 0 = пред. бит 7) | CY | [RLC/RRC/RAL/RAR](#rlc-rrc-ral-rar)
<span markdown="0" id="08">08</span> | {{danger}} | {NOP} | !!! | {{noflags}} | [Неопределенные инструкции](#неопределенные-инструкции)
<span markdown="0" id="09">09</span> | {{ alu16 }} | DAD B | HL <- HL + BC | {{noflags}} | [DAD](#dad)
<span markdown="0" id="0a">0A</span> | {{mov8}} | LDAX B | A <- (BC) | {{noflags}} | [LDAX/STAX](#ldax-stax)
<span markdown="0" id="0b">0B</span> | {{ alu16 }} | DCX B | BC <- BC - 1 | {{noflags}} | [INX/DCX](#inx-dcx)
<span markdown="0" id="0c">0C</span> | {{alu8}} | INR C | C <- C + 1 | Z, S, P, AC | [INR/DCR](#inr-dcr)
<span markdown="0" id="0d">0D</span> | {{alu8}} | DCR C | C <- C - 1 | Z, S, P, AC | [INR/DCR](#inr-dcr)
<span markdown="0" id="0e">0E</span> {2} | {{mov8}} | MVI C, d8 | C <- {2} | {{noflags}} | [MVI](#mvi)
<span markdown="0" id="0f">0F</span> | {{alu8}} | RRC | A <- A >> 1 (CY = пред. бит 0; бит 7 = пред. бит 0) | CY | [RLC/RRC/RAL/RAR](#rlc-rrc-ral-rar)
<span markdown="0" id="10">10</span> | {{danger}} | {NOP} | !!! | {{noflags}} | [Неопределенные инструкции](#неопределенные-инструкции)
<span markdown="0" id="11">11</span> {2} {3} | {{ mov16 }} | LXI D, d16 | D <- {2}, E <- {3} | {{noflags}} | [LXI](#lxi)
<span markdown="0" id="12">12</span> | {{mov8}} | STAX D | (DE) <- A | {{noflags}} | [LDAX/STAX](#ldax-stax)
<span markdown="0" id="13">13</span> | {{ alu16 }} | INX D  | DE <- DE + 1 | {{noflags}} | [INX/DCX](#inx-dcx)
<span markdown="0" id="14">14</span> | {{alu8}} | INR D | D <- D + 1 | Z, S, P, AC | [INR/DCR](#inr-dcr)
<span markdown="0" id="15">15</span> | {{alu8}} | DCR D | D <- D - 1 | Z, S, P, AC | [INR/DCR](#inr-dcr)
<span markdown="0" id="16">16</span> {2} | {{mov8}} | MVI D, d8 | D <- {2} | {{noflags}} | [MVI](#mvi)
<span markdown="0" id="17">17</span> | {{alu8}} | RAL | A <- A << 1 (бит 0 = пред. CY, CY = пред. бит 7) | CY | [RLC/RRC/RAL/RAR](#rlc-rrc-ral-rar)
<span markdown="0" id="18">18</span> | {{danger}} | {NOP} | !!! | {{noflags}} | [Неопределенные инструкции](#неопределенные-инструкции)
<span markdown="0" id="19">19</span> | {{ alu16 }} | DAD D | HL <- HL + DE | {{noflags}} | [DAD](#dad)
<span markdown="0" id="1a">1A</span> | {{mov8}} | LDAX D | A <- (DE) | {{noflags}} | [LDAX/STAX](#ldax-stax)
<span markdown="0" id="1b">1B</span> | {{ alu16 }} | DCX D | DE <- DE - 1 | {{noflags}} | [INX/DCX](#inx-dcx)
<span markdown="0" id="1c">1C</span> | {{alu8}} | INR E | E <- E + 1 | Z, S, P, AC | [INR/DCR](#inr-dcr)
<span markdown="0" id="1d">1D</span> | {{alu8}} | DCR E | E <- E - 1 | Z, S, P, AC | [INR/DCR](#inr-dcr)
<span markdown="0" id="1e">1E</span> {2} | {{mov8}} | MVI E, d8 | E <- {2} | {{noflags}} | [MVI](#mvi)
<span markdown="0" id="1f">1F</span> | {{alu8}} | RAR | A <- A >> 1 (бит 7 = пред. CY, CY = пред. бит 0) | CY | [RLC/RRC/RAL/RAR](#rlc-rrc-ral-rar)
<span markdown="0" id="20">20</span> | {{danger}} | {NOP} | !!! | {{noflags}} | [Неопределенные инструкции](#неопределенные-инструкции)
<span markdown="0" id="21">21</span> {2} {3} | {{ mov16 }} | LXI H, d16 | H <- {2}, L <- {3} | {{noflags}} | [LXI](#lxi)
<span markdown="0" id="22">22</span> {2} {3} | {{ mov16 }} | SHLD a16 | (a16) <- L, (a16+1) <- H | {{noflags}} | [SHLD/LHLD](#shld-lhld)
<span markdown="0" id="23">23</span> | {{ alu16 }} | INX H  | HL <- HL + 1 | {{noflags}} | [INX/DCX](#inx-dcx)
<span markdown="0" id="24">24</span> | {{alu8}} | INR H | H <- H + 1 | Z, S, P, AC | [INR/DCR](#inr-dcr)
<span markdown="0" id="25">25</span> | {{alu8}} | DCR H | H <- H - 1 | Z, S, P, AC | [INR/DCR](#inr-dcr)
<span markdown="0" id="26">26</span> {2} | {{mov8}} | MVI H, d8 | H <- {2} | {{noflags}} | [MVI](#mvi)
<span markdown="0" id="27">27</span> | {{alu8}} | DAA | Преобразовать A в формат BCD | CY, AC | [DAA](#daa)
<span markdown="0" id="28">28</span> | {{danger}} | {NOP} | !!! | {{noflags}} | [Неопределенные инструкции](#неопределенные-инструкции)
<span markdown="0" id="29">29</span> | {{ alu16 }} | DAD H | HL <- HL + HL | {{noflags}} | [DAD](#dad)
<span markdown="0" id="2a">2A</span> {2} {3} | {{ mov16 }} | LHLD a16 | L <- (a16), H <- (a16+1) | {{noflags}} | [LHLD/SHLD](#lhld-shld)
<span markdown="0" id="2b">2B</span> | {{ alu16 }} | DCX H | HL <- HL - 1 | {{noflags}} | [INX/DCX](#inx-dcx)
<span markdown="0" id="2c">2C</span> | {{alu8}} | INR L | L <- L + 1 | Z, S, P, AC | [INR/DCR](#inr-dcr)
<span markdown="0" id="2d">2D</span> | {{alu8}} | DCR L | L <- L - 1 | Z, S, P, AC | [INR/DCR](#inr-dcr)
<span markdown="0" id="2e">2E</span> {2} | {{mov8}} | MVI L, d8 | L <- {2} | {{noflags}} | [MVI](#mvi)
<span markdown="0" id="2f">2F</span> | {{alu8}} | CMA | A <- ~A | {{noflags}} | [CMA](#cma)
<span markdown="0" id="30">30</span> | {{danger}} | {NOP} | !!! | {{noflags}} | [Неопределенные инструкции](#неопределенные-инструкции)
<span markdown="0" id="31">31</span> {2} {3} | {{ mov16 }} | LXI SP, d16 | SP <- {2}, SP+1 <- {3} | {{noflags}} | [LXI](#lxi)
<span markdown="0" id="32">32</span> {2} {3} | {{mov8}} | STA a16 | (a16) <- A | {{noflags}} | [STA](#sta)
<span markdown="0" id="33">33</span> | {{ alu16 }} | INX SP | SP <- SP + 1 | {{noflags}} | [INX/DCX](#inx-dcx)
<span markdown="0" id="34">34</span> | {{alu8}} | INR M | (HL) <- (HL) + 1 | Z, S, P, AC | [INR/DCR](#inr-dcr)
<span markdown="0" id="35">35</span> | {{alu8}} | DCR M | (HL) <- (HL) - 1 | Z, S, P, AC | [INR/DCR](#inr-dcr)
<span markdown="0" id="36">36</span> {2} | {{mov8}} | MVI M, d8 | (HL) <- {2} | {{noflags}} | [MVI](#mvi)
<span markdown="0" id="37">37</span> | {{alu8}} | STC | CY <- 1 | {{noflags}} | [STC/CMC](#stc-cmc)
<span markdown="0" id="38">38</span> | {{danger}} | {NOP} | !!! | {{noflags}} | [Неопределенные инструкции](#неопределенные-инструкции)
<span markdown="0" id="39">39</span> | {{ alu16 }} | DAD SP | HL <- HL + SP | {{noflags}} | [DAD](#dad)
<span markdown="0" id="3a">3A</span> {2} {3} | {{mov8}} | LDA a16 | A <- (a16) | {{noflags}} | [LDA](#lda)
<span markdown="0" id="3b">3B</span> | {{ alu16 }} | DCX SP | SP <- SP - 1 | {{noflags}} | [INX/DCX](#inx-dcx)
<span markdown="0" id="3c">3C</span> | {{alu8}} | INR A | A <- A + 1 | Z, S, P, AC | [INR/DCR](#inr-dcr)
<span markdown="0" id="3d">3D</span> | {{alu8}} | DCR A | A <- A - 1 | Z, S, P, AC | [INR/DCR](#inr-dcr)
<span markdown="0" id="3e">3E</span> {2} | {{mov8}} | MVI A, d8 | A <- {2} | {{noflags}} | [MVI](#mvi)
<span markdown="0" id="3f">3F</span> | {{alu8}} | CMC | CY <- !CY | {{noflags}} | [STC/CMC](#stc-cmc)
<span markdown="0" id="40">40</span> | {{mov8}} | MOV B, B {NOP} | B <- B | {{noflags}} | [MOV](#mov)
<span markdown="0" id="41">41</span> | {{mov8}} | MOV B, C | B <- C | {{noflags}} | [MOV](#mov)
<span markdown="0" id="42">42</span> | {{mov8}} | MOV B, D | B <- D | {{noflags}} | [MOV](#mov)
<span markdown="0" id="43">43</span> | {{mov8}} | MOV B, E | B <- E | {{noflags}} | [MOV](#mov) 
<span markdown="0" id="44">44</span> | {{mov8}} | MOV B, H | B <- H | {{noflags}} | [MOV](#mov)
<span markdown="0" id="45">45</span> | {{mov8}} | MOV B, L | B <- L | {{noflags}} | [MOV](#mov)
<span markdown="0" id="46">46</span> | {{mov8}} | MOV B, M | B <- (HL) | {{noflags}} | [MOV](#mov)
<span markdown="0" id="47">47</span> | {{mov8}} | MOV B, A | B <- A | {{noflags}} | [MOV](#mov)
<span markdown="0" id="48">48</span> | {{mov8}} | MOV C, B | C <- B | {{noflags}} | [MOV](#mov)
<span markdown="0" id="49">49</span> | {{mov8}} | MOV C, C {NOP} | C <- C | {{noflags}} | [MOV](#mov)
<span markdown="0" id="4a">4A</span> | {{mov8}} | MOV C, D | C <- D | {{noflags}} | [MOV](#mov)
<span markdown="0" id="4b">4B</span> | {{mov8}} | MOV C, E | C <- E | {{noflags}} | [MOV](#mov)
<span markdown="0" id="4c">4C</span> | {{mov8}} | MOV C, H | C <- H | {{noflags}} | [MOV](#mov)
<span markdown="0" id="4d">4D</span> | {{mov8}} | MOV C, L | C <- L | {{noflags}} | [MOV](#mov)
<span markdown="0" id="4e">4E</span> | {{mov8}} | MOV C, M | C <- (HL) | {{noflags}} | [MOV](#mov)
<span markdown="0" id="4f">4F</span> | {{mov8}} | MOV C, A | C <- A | {{noflags}} | [MOV](#mov) 
<span markdown="0" id="50">50</span> | {{mov8}} | MOV D, B | D <- B | {{noflags}} | [MOV](#mov) 
<span markdown="0" id="51">51</span> | {{mov8}} | MOV D, C | D <- C | {{noflags}} | [MOV](#mov) 
<span markdown="0" id="52">52</span> | {{mov8}} | MOV D, D {NOP} | D <- D | {{noflags}} | [MOV](#mov)
<span markdown="0" id="53">53</span> | {{mov8}} | MOV D, E | D <- E | {{noflags}} | [MOV](#mov)
<span markdown="0" id="54">54</span> | {{mov8}} | MOV D, H | D <- H | {{noflags}} | [MOV](#mov)
<span markdown="0" id="55">55</span> | {{mov8}} | MOV D, L | D <- L | {{noflags}} | [MOV](#mov)
<span markdown="0" id="56">56</span> | {{mov8}} | MOV D, M | D <- (HL) |  {{noflags}} | [MOV](#mov)
<span markdown="0" id="57">57</span> | {{mov8}} | MOV D, A | D <- A | {{noflags}} | [MOV](#mov)
<span markdown="0" id="58">58</span> | {{mov8}} | MOV E, B | E <- B | {{noflags}} | [MOV](#mov)
<span markdown="0" id="59">59</span> | {{mov8}} | MOV E, C | E <- C | {{noflags}} | [MOV](#mov)
<span markdown="0" id="5a">5A</span> | {{mov8}} | MOV E, D | E <- D | {{noflags}} | [MOV](#mov)
<span markdown="0" id="5b">5B</span> | {{mov8}} | MOV E, E {NOP} | E <- E |   {{noflags}} | [MOV](#mov)
<span markdown="0" id="5c">5C</span> | {{mov8}} | MOV E, H | E <- H | {{noflags}} | [MOV](#mov)
<span markdown="0" id="5d">5D</span> | {{mov8}} | MOV E, L | E <- L | {{noflags}} | [MOV](#mov)
<span markdown="0" id="5e">5E</span> | {{mov8}} | MOV E, M | E <- (HL) |  {{noflags}} | [MOV](#mov)
<span markdown="0" id="5f">5F</span> | {{mov8}} | MOV E, A | E <- A | {{noflags}} | [MOV](#mov)
<span markdown="0" id="60">60</span> | {{mov8}} | MOV H, B | H <- B | {{noflags}} | [MOV](#mov)
<span markdown="0" id="61">61</span> | {{mov8}} | MOV H, C | H <- C | {{noflags}} | [MOV](#mov)
<span markdown="0" id="62">62</span> | {{mov8}} | MOV H, D | H <- D | {{noflags}} | [MOV](#mov)
<span markdown="0" id="63">63</span> | {{mov8}} | MOV H, E | H <- E | {{noflags}} | [MOV](#mov)
<span markdown="0" id="64">64</span> | {{mov8}} | MOV H, H {NOP} | H <- H | {{noflags}} | [MOV](#mov)
<span markdown="0" id="65">65</span> | {{mov8}} | MOV H, L | H <- L | {{noflags}} | [MOV](#mov)
<span markdown="0" id="66">66</span> | {{mov8}} | MOV H, M | H <- (HL) | {{noflags}} | [MOV](#mov)
<span markdown="0" id="67">67</span> | {{mov8}} | MOV H, A | H <- A | {{noflags}} | [MOV](#mov)
<span markdown="0" id="68">68</span> | {{mov8}} | MOV L, B | L <- B | {{noflags}} | [MOV](#mov)
<span markdown="0" id="69">69</span> | {{mov8}} | MOV L, C | L <- C | {{noflags}} | [MOV](#mov)
<span markdown="0" id="6a">6A</span> | {{mov8}} | MOV L, D | L <- D | {{noflags}} | [MOV](#mov)
<span markdown="0" id="6b">6B</span> | {{mov8}} | MOV L, E | L <- E | {{noflags}} | [MOV](#mov)
<span markdown="0" id="6c">6C</span> | {{mov8}} | MOV L, H | L <- H | {{noflags}} | [MOV](#mov)
<span markdown="0" id="6d">6D</span> | {{mov8}} | MOV L, L {NOP} | L <- L | {{noflags}} | [MOV](#mov)
<span markdown="0" id="6e">6E</span> | {{mov8}} | MOV L, M | L <- (HL) | {{noflags}} | [MOV](#mov)
<span markdown="0" id="6f">6F</span> | {{mov8}} | MOV L, A | L <- A | {{noflags}} | [MOV](#mov)
<span markdown="0" id="70">70</span> | {{mov8}} | MOV M, B | (HL) <- B | {{noflags}} | [MOV](#mov)
<span markdown="0" id="71">71</span> | {{mov8}} | MOV M, C | (HL) <- C | {{noflags}} | [MOV](#mov)
<span markdown="0" id="72">72</span> | {{mov8}} | MOV M, D | (HL) <- D | {{noflags}} | [MOV](#mov)
<span markdown="0" id="73">73</span> | {{mov8}} | MOV M, E | (HL) <- E | {{noflags}} | [MOV](#mov)
<span markdown="0" id="74">74</span> | {{mov8}} | MOV M, H | (HL) <- H | {{noflags}} | [MOV](#mov)
<span markdown="0" id="75">75</span> | {{mov8}} | MOV M, L | (HL) <- L | {{noflags}} | [MOV](#mov)
<span markdown="0" id="76">76</span> | {{control}} | HLT | Остановить процессор | {{noflags}} | [HLT](#hlt)
<span markdown="0" id="77">77</span> | {{mov8}} | MOV M, A | (HL) <- A | {{noflags}} | [MOV](#mov) 
<span markdown="0" id="78">78</span> | {{mov8}} | MOV A, B | A <- B | {{noflags}} | [MOV](#mov)
<span markdown="0" id="79">79</span> | {{mov8}} | MOV A, C | A <- C | {{noflags}} | [MOV](#mov)
<span markdown="0" id="7a">7A</span> | {{mov8}} | MOV A, D | A <- D | {{noflags}} | [MOV](#mov)
<span markdown="0" id="7b">7B</span> | {{mov8}} | MOV A, E | A <- E | {{noflags}} | [MOV](#mov)
<span markdown="0" id="7c">7C</span> | {{mov8}} | MOV A, H | A <- H | {{noflags}} | [MOV](#mov)
<span markdown="0" id="7d">7D</span> | {{mov8}} | MOV A, L | A <- L | {{noflags}} | [MOV](#mov)
<span markdown="0" id="7e">7E</span> | {{mov8}} | MOV A, M | A <- (HL) | {{noflags}} | [MOV](#mov)
<span markdown="0" id="7f">7F</span> | {{mov8}} | MOV A, A {NOP} | A <- A | {{noflags}} | [MOV](#mov)
<span markdown="0" id="80">80</span> | {{alu8}} | ADD B | A <- A + B | Z, S, P, CY, AC | [ADD](#add)
<span markdown="0" id="81">81</span> | {{alu8}} | ADD C | A <- A + C | Z, S, P, CY, AC | [ADD](#add)
<span markdown="0" id="82">82</span> | {{alu8}} | ADD D | A <- A + D | Z, S, P, CY, AC | [ADD](#add)
<span markdown="0" id="83">83</span> | {{alu8}} | ADD E | A <- A + E | Z, S, P, CY, AC | [ADD](#add)
<span markdown="0" id="84">84</span> | {{alu8}} | ADD H | A <- A + H | Z, S, P, CY, AC | [ADD](#add)
<span markdown="0" id="85">85</span> | {{alu8}} | ADD L | A <- A + L | Z, S, P, CY, AC | [ADD](#add)
<span markdown="0" id="86">86</span> | {{alu8}} | ADD M | A <- A + (HL) | Z, S, P, CY, AC | [ADD](#add)
<span markdown="0" id="87">87</span> | {{alu8}} | ADD A | A <- A + A | Z, S, P, CY, AC | [ADD](#add)
<span markdown="0" id="88">88</span> | {{alu8}} | ADC B | A <- A + B + CY | Z, S, P, CY, AC | [ADC](#adc)
<span markdown="0" id="89">89</span> | {{alu8}} | ADC C | A <- A + C + CY | Z, S, P, CY, AC | [ADC](#adc)
<span markdown="0" id="8a">8A</span> | {{alu8}} | ADC D | A <- A + D + CY | Z, S, P, CY, AC | [ADC](#adc)
<span markdown="0" id="8b">8B</span> | {{alu8}} | ADC E | A <- A + E + CY | Z, S, P, CY, AC | [ADC](#adc)
<span markdown="0" id="8c">8C</span> | {{alu8}} | ADC H | A <- A + H + CY | Z, S, P, CY, AC | [ADC](#adc)
<span markdown="0" id="8d">8D</span> | {{alu8}} | ADC L | A <- A + L + CY | Z, S, P, CY, AC | [ADC](#adc)
<span markdown="0" id="8e">8E</span> | {{alu8}} | ADC M | A <- A + (HL) + CY | Z, S, P, CY, AC | [ADC](#adc)
<span markdown="0" id="8f">8F</span> | {{alu8}} | ADC A | A <- A + A + CY | Z, S, P, CY, AC | [ADC](#adc)
<span markdown="0" id="90">90</span> | {{alu8}} | SUB B | A <- A - B | Z, S, P, CY, AC | [SUB](#sub)
<span markdown="0" id="91">91</span> | {{alu8}} | SUB C | A <- A - C | Z, S, P, CY, AC | [SUB](#sub)
<span markdown="0" id="92">92</span> | {{alu8}} | SUB D | A <- A - D | Z, S, P, CY, AC | [SUB](#sub)
<span markdown="0" id="93">93</span> | {{alu8}} | SUB E | A <- A - E | Z, S, P, CY, AC | [SUB](#sub)
<span markdown="0" id="94">94</span> | {{alu8}} | SUB H | A <- A - H | Z, S, P, CY, AC | [SUB](#sub)
<span markdown="0" id="95">95</span> | {{alu8}} | SUB L | A <- A - L | Z, S, P, CY, AC | [SUB](#sub)
<span markdown="0" id="96">96</span> | {{alu8}} | SUB M | A <- A - (HL) | Z, S, P, CY, AC | [SUB](#sub)
<span markdown="0" id="97">97</span> | {{alu8}} | SUB A | A <- A - A {A <- 0}| Z, S, P, CY, AC | [SUB](#sub)
<span markdown="0" id="98">98</span> | {{alu8}} | SBB B | A <- A - B - CY | Z, S, P, CY, AC | [SBB](#sbb)
<span markdown="0" id="99">99</span> | {{alu8}} | SBB C | A <- A - C - CY | Z, S, P, CY, AC | [SBB](#sbb)
<span markdown="0" id="9a">9A</span> | {{alu8}} | SBB D | A <- A - D - CY | Z, S, P, CY, AC | [SBB](#sbb)
<span markdown="0" id="9b">9B</span> | {{alu8}} | SBB E | A <- A - E - CY | Z, S, P, CY, AC | [SBB](#sbb)
<span markdown="0" id="9c">9C</span> | {{alu8}} | SBB H | A <- A - H - CY | Z, S, P, CY, AC | [SBB](#sbb)
<span markdown="0" id="9d">9D</span> | {{alu8}} | SBB L | A <- A - L - CY | Z, S, P, CY, AC | [SBB](#sbb)
<span markdown="0" id="9e">9E</span> | {{alu8}} | SBB M | A <- A - (HL) - CY | Z, S, P, CY, AC | [SBB](#sbb)
<span markdown="0" id="9f">9F</span> | {{alu8}} | SBB A | A <- A - A - CY | Z, S, P, CY, AC | [SBB](#sbb)
<span markdown="0" id="a0">A0</span> | {{alu8}} | ANA B | A <- A & B | Z, S, P, CY, AC | [ANA](#ana)
<span markdown="0" id="a1">A1</span> | {{alu8}} | ANA C | A <- A & C | Z, S, P, CY, AC | [ANA](#ana)
<span markdown="0" id="a2">A2</span> | {{alu8}} | ANA D | A <- A & D | Z, S, P, CY, AC | [ANA](#ana)
<span markdown="0" id="a3">A3</span> | {{alu8}} | ANA E | A <- A & E | Z, S, P, CY, AC | [ANA](#ana)
<span markdown="0" id="a4">A4</span> | {{alu8}} | ANA H | A <- A & H | Z, S, P, CY, AC | [ANA](#ana) 
<span markdown="0" id="a5">A5</span> | {{alu8}} | ANA L | A <- A & L | Z, S, P, CY, AC | [ANA](#ana)
<span markdown="0" id="a6">A6</span> | {{alu8}} | ANA M | A <- A & (HL) | Z, S, P, CY, AC | [ANA](#ana)
<span markdown="0" id="a7">A7</span> | {{alu8}} | ANA A | A <- A & A {NOP} | Z, S, P, CY, AC | [ANA](#ana)
<span markdown="0" id="a8">A8</span> | {{alu8}} | XRA B | A <- A ^ B | Z, S, P, CY, AC | [XRA](#xra)
<span markdown="0" id="a9">A9</span> | {{alu8}} | XRA C | A <- A ^ C | Z, S, P, CY, AC | [XRA](#xra)
<span markdown="0" id="aa">AA</span> | {{alu8}} | XRA D | A <- A ^ D | Z, S, P, CY, AC | [XRA](#xra)
<span markdown="0" id="ab">AB</span> | {{alu8}} | XRA E | A <- A ^ E | Z, S, P, CY, AC | [XRA](#xra)
<span markdown="0" id="ac">AC</span> | {{alu8}} | XRA H | A <- A ^ H | Z, S, P, CY, AC | [XRA](#xra)
<span markdown="0" id="ad">AD</span> | {{alu8}} | XRA L | A <- A ^ L | Z, S, P, CY, AC | [XRA](#xra)
<span markdown="0" id="ae">AE</span> | {{alu8}} | XRA M | A <- A ^ (HL) | Z, S, P, CY, AC | [XRA](#xra)
<span markdown="0" id="af">AF</span> | {{alu8}} | XRA A | A <- A ^ A {A <- 0} | Z, S, P, CY, AC | [XRA](#xra)
<span markdown="0" id="b0">B0</span> | {{alu8}} | ORA B | A <- A \| B | Z, S, P, CY, AC | [ORA](#ora)
<span markdown="0" id="b1">B1</span> | {{alu8}} | ORA C | A <- A \| C | Z, S, P, CY, AC | [ORA](#ora)
<span markdown="0" id="b2">B2</span> | {{alu8}} | ORA D | A <- A \| D | Z, S, P, CY, AC | [ORA](#ora)
<span markdown="0" id="b3">B3</span> | {{alu8}} | ORA E | A <- A \| E | Z, S, P, CY, AC | [ORA](#ora)
<span markdown="0" id="b4">B4</span> | {{alu8}} | ORA H | A <- A \| H | Z, S, P, CY, AC | [ORA](#ora)
<span markdown="0" id="b5">B5</span> | {{alu8}} | ORA L | A <- A \| L | Z, S, P, CY, AC | [ORA](#ora)
<span markdown="0" id="b6">B6</span> | {{alu8}} | ORA M | A <- A \| (HL) | Z, S, P, CY, AC | [ORA](#ora)
<span markdown="0" id="b7">B7</span> | {{alu8}} | ORA A | A <- A \| A {NOP} | Z, S, P, CY, AC | [ORA](#ora)
<span markdown="0" id="b8">B8</span> | {{alu8}} | CMP B | &empty; <- A - B | Z, S, P, CY, AC | [CMP](#cmp)
<span markdown="0" id="b9">B9</span> | {{alu8}} | CMP C | &empty; <- A - C | Z, S, P, CY, AC | [CMP](#cmp)
<span markdown="0" id="ba">BA</span> | {{alu8}} | CMP D | &empty; <- A - D | Z, S, P, CY, AC | [CMP](#cmp)
<span markdown="0" id="bb">BB</span> | {{alu8}} | CMP E | &empty; <- A - E | Z, S, P, CY, AC | [CMP](#cmp)
<span markdown="0" id="bc">BC</span> | {{alu8}} | CMP H | &empty; <- A - H | Z, S, P, CY, AC | [CMP](#cmp)
<span markdown="0" id="bd">BD</span> | {{alu8}} | CMP L | &empty; <- A - L | Z, S, P, CY, AC | [CMP](#cmp)
<span markdown="0" id="be">BE</span> | {{alu8}} | CMP M | &empty; <- A - (HL) | Z, S, P, CY, AC | [CMP](#cmp)
<span markdown="0" id="bf">BF</span> | {{alu8}} | CMP A | &empty; <- A - A | Z, S, P, CY, AC | [CMP](#cmp)
<span markdown="0" id="c0">C0</span> | {{jumps}} | RNZ | если не Z, PC <- POP() | {{noflags}} | [RET](#ret)
<span markdown="0" id="c1">C1</span> | {{ mov16 }} | POP B | BC <- POP() | {{noflags}} | [PUSH/POP](#push-pop)
<span markdown="0" id="c2">C2</span> {2} {3} | {{jumps}} | JNZ a16 | если не Z, PC <- a16 | {{noflags}} | [JMP](#jmp)
<span markdown="0" id="c3">C3</span> {2} {3} | {{jumps}} | JMP a16 | PC <- a16 | {{noflags}} | [JMP](#jmp)
<span markdown="0" id="c4">C4</span> {2} {3} | {{jumps}} | CNZ a16 | если не Z, PUSH(PC) и PC <- a16 | {{noflags}} | [CALL](#call)
<span markdown="0" id="c5">C5</span> | {{mov16}} | PUSH B | PUSH(BC) | {{noflags}} | [PUSH/POP](#push-pop)
<span markdown="0" id="c6">C6</span> {2} | {{alu8}} | ADI d8 | A <- A + {2} | Z, S, P, CY, AC | [ADD](#add)
<span markdown="0" id="c7">C7</span> | {{jumps}} | RST 0 | PUSH(PC) и PC <- 0x0000 | {{noflags}} | [RST](#rst)
<span markdown="0" id="c8">C8</span> | {{jumps}} | RZ | если Z, PC <- POP() | {{noflags}} | [RET](#ret)
<span markdown="0" id="c9">C9</span> | {{jumps}} | RET | PC <- POP() | {{noflags}} | [RET](#ret)
<span markdown="0" id="ca">CA</span> {2} {3} | {{jumps}} | JZ a16 | если Z, PC <- a16 | {{noflags}} | [JMP](#jmp)
<span markdown="0" id="cb">CB</span> {2} {3} | {{danger}} | {JMP a16} | !!! | {{noflags}} | [Неопределенные инструкции](#неопределенные-инструкции)
<span markdown="0" id="cc">CC</span> {2} {3} | {{jumps}} | CZ a16 | если Z, PUSH(PC) и PC <- a16 | {{noflags}} | [CALL](#call)
<span markdown="0" id="cd">CD</span> {2} {3} | {{jumps}} | CALL a16 | PUSH(PC) и PC <- a16 | {{noflags}} | [CALL](#call)
<span markdown="0" id="ce">CE</span> {2} | {{alu8}} | ACI d8 | A <- A + {2} + CY | Z, S, P, CY, AC | [Immediate-арифметика](#immediate-арифметика)
<span markdown="0" id="cf">CF</span> | {{jumps}} | RST 1 | PUSH(PC) и PC <- 0x0008 | {{noflags}} | [RST](#rst)
<span markdown="0" id="d0">D0</span> | {{jumps}} | RNC | если не CY, PC <- POP() | {{noflags}} | [RET](#ret)
<span markdown="0" id="d1">D1</span> | {{ mov16 }} | POP D | DE <- POP() | {{noflags}} | [PUSH/POP](#push-pop)
<span markdown="0" id="d2">D2</span> {2} {3} | {{jumps}} | JNC a16 | если не CY, PC <- a16 | {{noflags}} | [JMP](#jmp)
<span markdown="0" id="d3">D3</span> {2} | {{control}} | OUT d8 | если не CY, выводим A в порт {2} | {{noflags}} | [IN/OUT](#in-out)
<span markdown="0" id="d4">D4</span> {2} {3} | {{jumps}} | CNC a16 | если не CY, PUSH(PC) и PC <- a16 | {{noflags}} | [CALL](#call)
<span markdown="0" id="d5">D5</span> | {{mov16}} | PUSH D | PUSH(DE) | {{noflags}} | [PUSH/POP](#push-pop)
<span markdown="0" id="d6">D6</span> {2} | {{alu8}} | SUI d8 | A <- A - {2} | Z, S, P, CY, AC | [Immmediate-арифметика](#immediate-арифметика)
<span markdown="0" id="d7">D7</span> | {{jumps}} | RST 2 | PUSH(PC) и PC <- 0x0010 | {{noflags}} | [RST](#rst)
<span markdown="0" id="d8">D8</span> | {{jumps}} | RC | если не CY, PC <- POP() | {{noflags}} | [RET](#ret)
<span markdown="0" id="d9">D9</span> | {{danger}} | {RET} | !!! | {{noflags}} | [Неопределенные инструкции](#неопределенные-инструкции)
<span markdown="0" id="da">DA</span> {2} {3} | {{jumps}} | JC a16 | если CY, PC <- a16 | {{noflags}} | [JMP](#jmp)
<span markdown="0" id="db">DB</span> {2} {3} | {{control}} | IN d8 | считываем значение в A из порта {2} | {{noflags}} | [IN/OUT](#in-out)
<span markdown="0" id="dc">DC</span> {2} {3} | {{jumps}} | CC a16 | если CY, PUSH(PC) и PC <- a16 | {{noflags}} | [CALL](#call)
<span markdown="0" id="dd">DD</span> {2} {3} | {{danger}} | {CALL d16} | !!! | {{noflags}} | [Неопределенные инструкции](#неопределенные-инструкции)
<span markdown="0" id="de">DE</span> {2} | {{alu8}} | SBI d8 | A <- A - {2} - CY | Z, S, P, CY, AC | [Immediate-арифметика](#immediate-арифметика)
<span markdown="0" id="df">DF</span> | {{jumps}} | RST 3 | PUSH(PC) и PC <- 0x0018 | {{noflags}} | [RST](#rst)
<span markdown="0" id="e0">E0</span> {2} {3} | {{jumps}} | RPO | если не P, PC <- POP() | {{noflags}} | [RET](#ret)
<span markdown="0" id="e1">E1</span> | {{ mov16 }} | POP H | HL <- POP() | {{noflags}} | [PUSH/POP](#push-pop)
<span markdown="0" id="e2">E2</span> {2} {3} | {{jumps}} | JPO a16 | если не P, PC <- a16 | {{noflags}} | [JMP](#jmp)
<span markdown="0" id="e3">E3</span> {2} {3} | {{ mov16 }} | XTHL | tmp1 <- (SP); tmp2 <- (SP+1); (SP) <- L; (SP+1) <- H; H <- tmp1; L <- tmp2 | {{noflags}} | [XTHL](#xthl)
<span markdown="0" id="e4">E4</span> {2} {3} | {{jumps}} | CPO a16 | если не P, PUSH(PC) и PC <- a16 | {{noflags}} | [CALL](#call)
<span markdown="0" id="e5">E5</span> | {{mov16}} | PUSH H | PUSH(HL) | {{noflags}} | [PUSH/POP](#push-pop)
<span markdown="0" id="e6">E6</span> {2} | {{alu8}} | ANI d8 | A <- A & {2} | Z, S, P, CY, AC | [Immediate-арифметика](#immediate-арифметика)
<span markdown="0" id="e7">E7</span> | {{jumps}} | RST 4 | PUSH(PC) и PC <- 0x0020 | {{noflags}} | [RST](#rst)
<span markdown="0" id="e8">E8</span> | {{jumps}} | RPE | если P, PC <- POP() | {{noflags}} | [RET](#ret)
<span markdown="0" id="e9">E9</span> | {{jumps}} | PCHL | PC <- HL {JMP HL} | {{noflags}} | [JMP](#jmp)
<span markdown="0" id="ea">EA</span> {2} {3} | {{jumps}} | JPE a16 | если P, PC <- a16 | {{noflags}} | [JMP](#jmp)
<span markdown="0" id="eb">EB</span> {2} {3} | {{ mov16 }} | XCHG | tmp <- DE; DE <- HL; HL <- tmp | {{noflags}} | [XCHG](#xchg)
<span markdown="0" id="ec">EC</span> {2} {3} | {{jumps}} | CPE a16 | если P, PUSH(PC) и PC <- a16 | {{noflags}} | [CALL](#call)
<span markdown="0" id="ed">ED</span> {2} {3} | {{danger}} | {CALL d16} | !!! | {{noflags}} | [Неопределенные инструкции](#неопределенные-инструкции)
<span markdown="0" id="ee">EE</span> {2} | {{alu8}} | XRI d8 | A <- A ^ {2} | Z, S, P, CY, AC | [Immediate-арифметика](#immediate-арифметика)
<span markdown="0" id="ef">EF</span> | {{jumps}} | RST 5 | PUSH(PC) и PC <- 0x0028 | {{noflags}} | [RST](#rst)
<span markdown="0" id="f0">F0</span> {2} {3} | {{jumps}} | RP | если не S, PC <- POP() | {{noflags}} | [RET](#ret)
<span markdown="0" id="f1">F1</span> | {{ mov16 }} | POP PSW | AF <- POP() | Z, S, P, CY, AC | [PUSH/POP](#push-pop)
<span markdown="0" id="f2">F2</span> {2} {3} | {{jumps}} | JP a16 | если не S, PC <- a16 | {{noflags}} | [JMP](#jmp)
<span markdown="0" id="f3">F3</span> {2} {3} | {{control}} | DI | выключаем систему прирываний (INTE <- 0) | {{noflags}} | [DI/EI](#di-ei)
<span markdown="0" id="f4">F4</span> {2} {3} | {{jumps}} | CP a16 | если не S, PUSH(PC) и PC <- a16 | {{noflags}} | [CALL](#call)
<span markdown="0" id="f5">F5</span> | {{ mov16 }} | PUSH PSW | PUSH(AF) | {{noflags}} | [PUSH/POP](#push-pop)
<span markdown="0" id="f6">F6</span> {2} | {{alu8}} | ORI d8 | A <- A \| {2} | Z, S, P, CY, AC | [Immediate-арифметика](#immediate-арифметика)
<span markdown="0" id="f7">F7</span> | {{jumps}} | RST 6 | PUSH(PC) и PC <- 0x0030 | {{noflags}} | [RST](#rst)
<span markdown="0" id="f8">F8</span> {2} {3} | {{jumps}} | RM | если не S, PC <- POP() | {{noflags}} | [RET](#ret)
<span markdown="0" id="f9">F9</span> | {{ mov16 }} | SPHL | SP <- HL | {{noflags}} | [PUSH/POP](#push-pop)
<span markdown="0" id="fa">FA</span> {2} {3} | {{jumps}} | JM a16 | если S, PC <- a16 | {{noflags}} | [JMP](#jmp)
<span markdown="0" id="fb">FB</span> {2} {3} | {{control}} | EI | включаем систему прирываний (INTE <- 1) | {{noflags}} | [DI/EI](#di-ei)
<span markdown="0" id="fc">FC</span> {2} {3} | {{jumps}} | CM a16 | если S, PUSH(PC) и PC <- a16 | {{noflags}} | [CALL](#call)
<span markdown="0" id="fd">FD</span> {2} {3} | {{danger}} | {CALL d16} | !!! | {{noflags}} | [Неопределенные инструкции](#неопределенные-инструкции)
<span markdown="0" id="fe">FE</span> {2} | {{alu8}} | CPI d8 | &empty; <- A - {2} | Z, S, P, CY, AC | [Immediate-арифметика](#immediate-арифметика)
<span markdown="0" id="ff">FF</span> | {{jumps}} | RST 7 | PUSH(PC) и PC <- 0x0038 | {{noflags}} | [RST](#rst)
{: id="opcodes"}

# Таблица опкодов

*under construction*

-- | x0 | x1 | x2 | x3 | x4 | x5 | x6 | x7 | x8 | x9 | xA | xB | xC | xD | xE | xF | 
--:|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|
0x | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. |
1x | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. |
2x | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. |
3x | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. |
4x | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. |
5x | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. |
6x | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. |
7x | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. |
8x | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. |
9x | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. |
Ax | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. |
Bx | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. |
Cx | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. |
Dx | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. |
Ex | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. |
Fx | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. | .. |


# Инструкции
{: #categories }

У процессора есть несколко категорий команд:

- [{{ control }} Управление процессором](#control)
- [{{ jumps }} Переходы и вызовы](#jumps)
- [{{ mov8 }} Загрузка, сохранение и перемещение, 8-бит](#mov8)
- [{{ mov16 }} Загрузка, сохранение и перемещение, 16-бит](#mov16)
- [{{ alu8 }} Арифметические и логические операции, 8-бит](#alu8)
- [{{ alu16 }} Арифметические и логические операции, 16-бит](#alu16)

{% assign up="&#x2b06;" %}{% comment %}U+2B06 UP ARROW{% endcomment %}

## {{ control }} Управление процессором 
{: #control }

[{{up}} Вернуться к категориям инструкций](#categories)

Эти инструкции отвечают за операции, которые нельзя отнести к другим категориям.
Они редко используются при написании прикладных программ, и больше относятся к разработке системы.

### NOP

[{{up}} Вернуться к инструкциям управления процессором](#control)

Выполнение инструкции `NOP` не изменяет ничего.

Опкод инструкции `NOP` равен `0x00`, что значит, что по умолчанию память эмулятора СМ-1800 полностью заполнена `NOP`-инструкциями.
Это значит, что если выполнять код в незаданной памяти, то процессор будет выполнять инструкции `NOP`, пока не дойдет до какого-то другого кода.

{% capture sample %}
```asm
; Не делать ничего
NOP
```
{% endcapture %}
{% include code-sample.html content=sample %}

### HLT

[{{up}} Вернуться к инструкциям управления процессором](#control)

Инструкция `HLT` останавливает выполнение процессора.

После выполнения этой инструкции процессор входит в состояние, в котором выполнение кода прекращается до получения внешнего прерывания.
Если внешнее прерывание получено, то процессор считывает с линий данных один байт инструкции (обычно это одна из [RST-инструкций](#rst)) и выполняет её.

Если перед тем, как процессор вошел в `HLT`-состояние, были [выключены прерывания](#di-ei), то процессор больше никогда не будет выполнять код до полной перезагрузки.

Следует заметить, что эта инструкция имеет опкод `0x76` -- такой опкод, который был бы у гипотетической инструкции `MOV M,M`.

    
{% capture sample %}
```asm
; Остановить выполнение навсегда
DI
HLT
```
{% endcapture %}
{% include code-sample.html content=sample %}

### IN/OUT

[{{up}} Вернуться к инструкциям управления процессором](#control)

Инструкции `IN d8` и `OUT d8` используются для того, чтобы передавать данные во внешний порт или принимать данные из внешнего порта.
Какой именно смысл имеют эти порты, зависит от конкретного оборудования вокруг процессора.
Для систем, в которых есть системные вызовы (вроде СМ-1800), чаще всего следует не использовать эти инструкции самому, а вместо этого вызывать системные подпрограммы для выполнения таких задач.

На аппаратном уровне [можно считать, что у Intel 8080 на самом деле 17-битная адресная шина](https://stackoverflow.com/a/13750889/5936187), где верхняя линия -- это `IORQ`, которая равна 0 при обычной работе с памятью и 1 при выполнении `IN` и `OUT`.

При выполнении `OUT`, нижние 8 бит адресной шины устанавливаются в значение, переданное как аргумент инструкции. После этого процессор выдает значение A на линию данных, и внешнее оборудование может прочитать его оттуда.

При выполнении `IN`, нижние 8 бит устанавливаются в значение аргумента инструкции. После этого внешнее оборудование должно передать значение в процессор на линию данных, которое процессор принимает и записывает в регистр A.


{% capture sample %}
```asm
; Передать значение 0x55 в порт 0xC3
MVI A, 0x55
OUT 0xC3

; Читать значение из порта 0xA2
IN 0xA2
```
{% endcapture %}
{% include code-sample.html content=sample %}

### DI/EI

[{{up}} Вернуться к инструкциям управления процессором](#control)

Пара инструкций `DI` и `EI` используется для управления прерываниями. `DI` (*disable interrupts*) выключает прерывания, а `EI` (*enable interrupts*) включает их.

Прерывания -- это способ позволить оборудованию вокруг процессора останавливать выполнение основной программы и вместо этого делать некое действие в ответ на внешнее событие.

Прерывания [работают следующим образом](https://stackoverflow.com/a/26197699/5936187): если внешнее оборудование хочет вызвать прерывание, то подается сигнал на линию прерываний.
Когда процессор завершает текущую инструкцию, он подтверждает, что получил прерывание.
После этого внешнее оборудование должно подать на линию данных инструкцию из одного байта -- чаще всего это одна из [`RST`-инструкций](#rst).

После того, как прерывание произошло и было обработано, прерывания выключаются, поэтому если нужно обрабатывать последующие прерывания, то нужно включить их еще раз.


{% capture sample %}
```asm
; Подождем до получения следующего прерывания
EI
HLT ; zzz...

; Если мы здесь, то мы уже получили и обработали прерывание
; Снова включим получение прерываний 
EI
```
{% endcapture %}
{% include code-sample.html content=sample %}

## {{ jumps }} Переходы и вызовы 
{: #jumps }

Эти инструкции служат для изменения потока выполнения программы.
Используя эти инструкции, можно реализовать циклы, процедуры и функции, условные блоки (`if`/`else`) и другие похожие конструкции высокоуровневых языков программирования.

### Условные инструкции
{: #conditionals }

[{{up}} Вернуться к переходам и вызовам](#jumps)

У инструкций перехода есть три вида: [`JMP`](#jmp), [`CALL`](#call) и [`RET`](#ret).
Каждый из этих видов имеет 9 различных вариантов: один выполняет свое действие всегда, а остальные -- в зависимости от текущего состояния флагов процессора.
Все инструкции одного и того же вида имеют одинаковое поведение, если они выполняют переход,
поэтому их действие описано один раз для каждого вида.


| [`JMP`](#jmp) | [`CALL`](#call) | [`RET`](#ret) | переходит безусловно
| `JZ`  | `CZ`  | `RZ`  | переходит, если установлен флаг Z (результат равен 0)
| `JNZ` | `CNZ` | `RNZ` | переходит, если не установлен флаг Z (результат не равен 0)
| `JC`  | `CC`  | `RC`  | переходит, если установлен флаг CY (есть переполнение)
| `JNC` | `CNC` | `RNC` | переходит, если не установлен флаг CY (нет переполнения)
| `JPE` | `CPE` | `RPE` | переходит, если установлен флаг P (количество единиц в результате -- четное)
| `JPO` | `CPO` | `RPO` | переходит, если не установлен флаг P (количество единиц в результате -- нечетное)
| `JM`  | `CM`  | `RM`  | переходит, если установлен флаг S (результат меньше 0)
| `JP`  | `CP`  | `RP`  | переходит, если не установлен флаг S (результат больше или равен 0)


### JMP

[{{up}} Вернуться к переходам и вызовам](#jumps)

[Эта инструкция имеет условные варианты.](#conditionals)

Инструкция `JMP a16` принимает аргумент в виде адреса.
Если выполняется переход, то следующая инструкция, которую процессор начнет выполнять, будет находиться по этому адресу.

Эта инструкция может быть использована для того, чтобы:
- делать циклы
- реализовывать условные операторы
- пропускать куски памяти, которые не являются кодом

{% capture sample %}
```asm
; Перейти к адресу 0x1234
JMP 0x1234
; (или, если написать байты раздельно)
JMP 0x34 0x12
```

Выполним какое-то действие 10 раз:
```
; Сначала инициализируем счетчик: пусть в регистре A будет значение 10
MVI A, 10
; Метка начала цикла
loop:
    ; Выполним какое-то действие
    NOP ; ...
    NOP ; ...
    ; Сделали действие!
    ; Теперь вычтем единицу из счетчика
    DCR A
    ; Если счетчик еще не равен нулю, перейдем к началу цикла
    JNZ loop
; Если мы здесь, то мы не сделали переход в начало, значит цикл завершился
NOP ; ...
```


Получим значение из порта, и если оно имеет четное количество единиц, то выведем другое значение:
```
; Сначала считываем значение
IN 0xD0
; Проверяем его (устанавливаем флаги)
CPI 0x00
; Если оно не четное, то нужно пропустить следующий кусок кода
JPO not_even_parity
    ; Если мы здесь, то значение имеет четное количество единиц, и мы делаем вывод
    MVI A, 0x20
    OUT 0xD0
not_even_parity:
; Если мы здесь, значит мы либо выполнили переход и пропустили вывод, либо только что сделали вывод
NOP ; ...
```

Добавим строку внутри кода:
```
NOP ; ...
NOP ; ...
; Сейчас я хочу вывести какую-то строку на экран,
; но я хочу записать эту строку прямо здесь в памяти.
; Чтобы процессор не начал выполнять эту строку как код, мы должны пропустить ее.
JMP skip_string  ; перейдем на метку, которая после конца строки
string:  ; эта метка будет обозначать начало строки
  DB "HELLO WORLD!\0"  ; запишем строку в память
skip_string:  ; эта метка указывает на инструкции после конца строки
LXI BC, string  ; передадим адрес строки в регистр BC
CALL 0x0043     ; вызовем функцию вывода строки
```
{% endcapture %}
{% include code-sample.html content=sample %}

### CALL

[{{up}} Вернуться к переходам и вызовам](#jumps)

[Эта инструкция имеет условные варианты.](#conditionals)

Инструкция `CALL a16`, как и инструкция `JMP a16`, принимает в качестве аргумента адрес, к которому нужно перейти.
Однако при вызове `CALL`, помимо перехода, дополнительно значение регистра PC записывается в стек.
Это нужно, чтобы будущая инструкция [`RET`](#ret) могла вернуться в этот код.

Эта инструкция используется для того, чтобы вызывать подпрограммы -- куски кода, которые нужно использовать несколько раз.
Когда выполняется `CALL`, процессор запоминает на стек, как вернуться к основной программе, и затем начинает выполнять подпрограмму.
Когда подпрограмма завершается, она использует инструкцию `RET`, и процессор достает этот запомненный адрес из стека и переходит к нему, возвращаясь в основную программу.

Инструкция `CALL` только сохраняет адрес возврата в стеке -- она не изменяет регистры или флаги. Это означает, что текущие значения регистров доступны подпрограмме, и являются основным способом передачи данных в подпрограмму.

{% capture sample %}
```asm
; Подпрограмма, которая умножает значение в регистре A на 10
times_10:
    ; мы будем использовать регистр B как временное хранилище
    ; запишем его текущее значение на стек
    PUSH BC
    ; A = x
    ADD A    ; A = x + x = 2*x
    MOV B,A  ; B = A = 2*x
    ADD A    ; A = 2*x + 2*x = 4*x
    ADD A    ; A = 4*x + 4*x = 8*x
    ADD B    ; A = 8*x + 2*x = 10*x
    ; вернем значение из стека в регистр B
    POP BC
    ; возвращаемся в основную программу
    RET

; Установим значение регистра A
MVI A, 3
; Вызовем подпрограмму
CALL times_10
; Теперь значение регистра A будет равно 30
```
{% endcapture %}
{% include code-sample.html content=sample %}

### RET

[{{up}} Вернуться к переходам и вызовам](#jumps)

[Эта инструкция имеет условные варианты.](#conditionals)

Инструкция `RET` считывает значение из стека и переходит к адресу, записанному в этом значении.

Используя эту инструкцию, можно создавать подпрограммы --
куски кода, которые можно использовать несколько раз из разных мест основной программы.

Если подпрограмма использует [инструкции управления стеком](#push-pop), то следует быть аккуратным при написании кода,
чтобы к моменту вызова `RET` стек был на том же уровне, что и в начале подпрограммы.
Это из-за того, что при вызове `RET`, процессор достает значение из стека и переходит к адресу, записанному в этом значении,
и если программа выполнила `PUSH`, который не был взят обратно с `POP`,
то при попытке вернуться в основную программу, процессор вместо этого не вернется к ожидаемому адресу.

{% capture sample %}
```asm
; Подпрограмма, которая умножает значение в регистре A на 10
times_10:
    ; мы будем использовать регистр B как временное хранилище
    ; запишем его текущее значение на стек
    PUSH BC
    ; A = x
    ADD A    ; A = x + x = 2*x
    MOV B,A  ; B = A = 2*x
    ADD A    ; A = 2*x + 2*x = 4*x
    ADD A    ; A = 4*x + 4*x = 8*x
    ADD B    ; A = 8*x + 2*x = 10*x
    ; вернем значение из стека в регистр B
    POP BC
    ; возвращаемся в основную программу
    RET

; Установим значение регистра A
MVI A, 3
; Вызовем подпрограмму
CALL times_10
; Теперь значение регистра A будет равно 30
```

Пример проблемы при вызове `RET` с использованием стека:

```asm
; Подпрограмма, которая делает что-то полезное
subprogram:
  NOP  ; ...
  NOP  ; ...
  ; ... Во время работы подпрограммы мы положили значение на стек
  MVI H, 0x40
  MVI L, 0x00
  PUSH HL
  NOP  ; ...
  NOP  ; ...
  ; !!! Мы забыли сделать POP !!!
  RET  ; Этот RET считает значение от PUSH и перейдет к адресу 0x4000 !!


; Если попробовать использовать эту подпрограмму в основной программе...
NOP   ; ...
NOP   ; ...
CALL subprogram
NOP   ; <-- Этот код не будет выполнен -- мы не вернемся сюда
```
{% endcapture %}
{% include code-sample.html content=sample %}


### RST

[{{up}} Вернуться к переходам и вызовам](#jumps)

Инструкции `RST 0`, `RST 1` ... `RST 7` выполняют то же самое, что [`CALL`](#call), к адресу `0x0000 + n*8`, где `n` от 0 до 7.
Это означает, что при вызове `RST 0`, процессор перейдет к адресу `0x0000`,
при вызове `RST 1` процессор перейдет к адресу `0x0008`,
при вызове `RST 2` процессор перейдет к адресу `0x0010` и т.д.

Эти инструкции полезны больше всего для работы с внешними прерываниями.
Когда происходит прерывание, процессор считывает и выполняет одну инструкцию с шины данных,
прежде чем продолжить работать как обычно.
Каждая из инструкций `RST` занимает один байт, поэтому
если в этот момент на шине данных выставить один из восьми опкодов `RST`,
то процессор запомнит свое последнее положение в коде на стек.
и выполнит код для обработки прерывания.
Процедура прерывания затем может использовать [`RET`](#ret), чтобы вернуться к основному коду и продолжить работу как обычно.

Эти опкоды также являются обычными инструкциями, поэтому можно использовать их в своем коде.
Например, если вызвать инструкцию `RST 0`, то процессор перейдет к адресу `0x0000`,
как будто он был толькол что перезагружен с помощью линии `RESET`.

{% capture sample %}
```asm
; Бесконечно принимаем значение из порта
; Если это значение стало равно 0, перезагружаем процессор
loop:
  IN 0x80   ; считываем значение
  CPI 0x00  ; сравниваем с 0
  JNZ loop  ; если не равно, продолжаем цикл
; теперь значение равно 0
RST 0     ; перезагружаем процессор
```
{% endcapture %}
{% include code-sample.html content=sample %}

